/**
 * ML-DSA (CRYSTALS-Dilithium) signature scheme.
 *
 * This provides an algorithm for digital signatures with non-repudiation,
 * designed to be secure against an adversary with a large-scale quantum
 * computer.
 *
 * This executable specification matches the final version of [FIPS-204].
 *
 * References:
 * [FIPS-204]: National Institute of Standards and Technology. Module-Lattice-
 *     Based Digital Signature Standard. (Department of Commerce, Washington,
 *     D.C.), Federal Information Processing Standards Publication (FIPS) NIST
 *     FIPS 204. August 2024.
 *     @see https://doi.org/10.6028/NIST.FIPS.204
 *
 * @copyright Galois Inc
 * @author Marcella Hastings <marcella@galois.com>
 */
module Primitive::Asymmetric::Signature::ML_DSA::Specification where

type Byte = [8]

/**
 * The ring of single-variable polynomials over the integers mod 2, modulo
 * `X^256 + 1`.
 * [FIPS-204] Section 2.3 and Section 2.4.1.
 *
 * We represent individual elements in `ℤ_2` as bits, so this is just a bit
 * array.
 */
type R2 = [256]

parameter
    /**
     * Modulus defining the ring used throughout the protocol.
     * [FIPS-204] Section 4, Table 1.
     */
    type q = 8380417

    /**
     * Hamming weight of the mask sampled in signing.
     *
     * The spec describes this as "number of ±1s in polynomial `c`", where `c`
     * is the verifier's challenge.
     * [FIPS-204] Section 4, Table 1.
     *
     * The type constraint is drawn from [FIPS-204] Section 7.3, Algorithm 29.
     */
    type τ : #
    type constraint (τ <= 64)

    /**
     * Collision strength of the commitment hash `c~` component of a signature.
     * [FIPS-204] Section 4, Table 1.
     */
    type λ : #

    /**
     * Coefficient range of the commitment mask `y` used in signing.
     * [FIPS-204] Section 4, Table 1.
     *
     * The type constraint, which claims that γ1 must be a power of 2, is drawn
     * from [FIPS-203] Section 7.2, Algorithm 27.
     */
    type γ1 : #
    type constraint (2 ^^ (lg2 γ1) == γ1)

    /**
     * Low-order rounding range; this defines how to round the signer's
     * commitment `w`.
     * [FIPS-204] Section 4, Table 1.
     *
     * The type constraint is drawn from [FIPS-204] Section 7.4. The primary
     * constraint we wish to encode is that `2 * γ2` divides `q - 1`;
     * to express this, we must also require that γ2 is non-zero.
     */
    type γ2 : #
    type constraint (γ2 > 0, (q - 1) % (2 * γ2) == 0)

    /**
     * Dimensions of the matrix `A`, which is part of the public key.
     * [FIPS-204] Section 4, Table 1.
     */
    type k : #
    type ell : #
    type constraint (fin k, fin ell)

    /**
     * Private key range; the private key is a polynomial whose coefficients
     * are all in a range defined by η.
     * [FIPS-204] Section 4, Table 1.
     *
     * The type constraint (that η must be in the set {2, 4}) is drawn from
     * [FIPS-204] Section 7.1, Algorithm 15.
     */
    type η : #
    type constraint (η % 2 == 0, 2 <= η, η <= 4)

    /**
     * Maximum Hamming weight for the hint component of a signature.
     * [FIPS-204] Section 4, Table 1.
     */
    type ω : #

/**
 * A 512th root of unity in `Z_q`.
 * [FIPS-204] Section 4, Table 1.
 */
type ζ = 1753

/**
 * Number of dropped bits from `t` (this compresses the public key for
 * a performance optimization).
 * [FIPS-204] Section 4, Table 1.
 */
type d = 13

/**
 * Allowable error range for signature components. In signing, this is used to
 * determine if a candidate signature is valid.
 * [FIPS-204] Section 4, Table 1.
 */
type β = η * τ


HintBitPack : [k]R2 -> [ω + k]Byte
HintBitPack h = y where
    y_Indexes = findOnes (join h) 0 []

    // TODO : add "count-for-each-h" list at the end.

    y = zero

private
    /**
     * Helper function for `HintBitPack` that records all the indexes of all
     * the non-zero elements of `h`
     * [FIPS-204] Section 7.1, Algorithm 20, Steps 1-9.
     *
     * The top-level call should set:
     * - h = the entire hint, joined into one array;
     * - j = 0 (as in Step 4);
     * - yIndex = [] (to indicate that we have not identified any non-zero
     *   entries yet).
     *
     * This does not look like the spec; we try to provide intuition:
     * - This function assumes the hint `h` is passed as a flattened single
     *   array (rather than a 2D array as described in the spec). This gives us
     *   a single recursive iterator `j` instead of two, like the pair of
     *   loops in the spec. In the recursive case, a single iterator has a much
     *   simpler type signature compared to a dual-iterator implementation.
     * - The iterator `j` is a `Byte` so it will increase `mod 256`. This
     *   mimics the behavior in the inner loop in Step 4, and ensures that
     *   `y[Index]` is set to the correct value.
     * - We don't explicitly track the value of `Index`; instead, we build up
     *   the array `y_Index` as we encounter each non-zero entry. Once we've
     *   traversed the entire hint, we pad the remaining potential-index bytes
     *   with 0, per Step 1.
     *
     * This function does _not_ implement Step 10 of Algorithm 20!
     */
    findOnes : {m, n} (fin m, fin n) => [m] -> Byte -> [n]Byte -> [ω]Byte
    findOnes h j yIndex
        | (m == 0, n > ω) => error "the hint had too many non-zero entries!"
        | (m == 0, n <= ω) => yIndex # zero
        | (m > 0) =>
            if hi_j == 1 then
                findOnes h_tail (j + 1) (yIndex # [j])
            else
                findOnes h_tail (j + 1) yIndex
            where
                ([hi_j] # h_tail) = h
