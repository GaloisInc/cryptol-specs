/*
 * This module implements FIPS204 ML-DSA Final Draft.
 *
 * This specification was developed in collaboration with MITRE.
 */
module DilithiumParameterized where
import Primitive::Keyless::Hash::SHAKE::SHAKE128 as SHA3 (shake128)
import Primitive::Keyless::Hash::SHAKE::SHAKE256 as SHA3 (shake256)
import Primitive::Keyless::Hash::utils as SHA3 (toBytes)
import Common::utils (dowhile, unzip, while)

// Parameterize the types based on the implementations, weak, medium,
// recommended, and very-high
parameter
    type Q = 0x7fe001 //8380417
    type gamma1 : #
    type constraint (fin gamma1, gamma1 >= (2^^17), gamma1 <= (2^^19))
    type gamma2 : #
    type constraint (fin gamma2, gamma2 >= 95232, gamma2 <= 261888)
    type k : #
    type constraint (fin k, k >= 4, k <= 8)
    type l : #
    type constraint (fin l, l >= 4, l <= 7)
    type eta : #
    type constraint (fin eta, eta >= 2, eta <= 4)
    beta : (Z Q)
    type omega : #
    type constraint (fin omega, omega >= 55, omega <= 80)
    type tau : #
    type constraint (fin tau, tau >= 39, tau <= 60)
    type lambda : #
    type constraint (fin lambda, lambda >= 128,lambda <= 256, lambda%8 == 0)

// To expose the parameters
type GAMMA1 = gamma1
type GAMMA2 = gamma2
type K = k
type L = l
type ETA = eta
BETA = beta
type OMEGA = omega
type TAU = tau
type LAMBDA = lambda

// Fixed parameters
type QBits = 23
type UInt32T = 32
type N = 0x100 //256
type D = 0xd
WC = 0x3c //60 CHANGE
type ALPHA = 2*GAMMA2  //2 * GAMMA2 : [_]
QINV  = 0x00000000fc7fdfff
type SetaBits = 4

// Parameters for Number Theoretic Transform (NTT)
ROOTOFUNITY    = 1753 : (Z Q)
ROOTOFUNITYINV = 731434 : (Z Q)
NINV           = 8347681 : (Z Q)

// Polynomials; a superset of ring R_q referenced in specification
type Poly        = [N](Z Q) // This is R_q, actually defines a super set of R_q
type PolyVec dim = [dim]Poly

// Polynomials in NTT representation
type NttPoly          = Poly
type NttVec dim       = [dim]NttPoly
type NttMat dim1 dim2 = [dim1](NttVec dim2)

//Public key type
type PublicKey = { rho : [256], t1 : PolyVec K }
//Public Key Bytes
type PublicKeyBytes = 32+32*K*(width(Q-1)-D)

// Secret Key structure
type SecretKey = { rho : [256]
                 , key : [256]
                 , tr : [512]
                 , s1 : PolyVec L
                 , s2 : PolyVec K
                 , t0 : PolyVec K
                 }
//Secret Key Bytes
type SecretKeyBytes = 32+32+64+32*((K+L)*width(2*eta)+D*K)

//Signature Structure
type SigTypes = { cTil : [2*LAMBDA]
                , z : PolyVec L
                , h : PolyVec K
                }
//Signature Bytes
type SigBytes = LAMBDA/4+L*32*(1+width(GAMMA1-1))+OMEGA+K

//types for sign dowhile loop
type SignVarTypes = { z : PolyVec L
                    , r0  : PolyVec K
                    , t0Hat : NttVec K
                    , cTil : [2*LAMBDA]
                    , cNtt  : NttPoly
                    , w   : PolyVec K
                    , w1  : PolyVec K
                    , s1Hat : NttVec L
                    , s2Hat : NttVec K
                    , cs2 : PolyVec K
                    , mu  : [512]
                    , rho' : [512]
                    , a   : NttMat K L
                    , kappa: Integer
                    }

//Bytes for W1
type W1Packed = 32*K*width((Q-1)/((2*GAMMA2)-1))

//hash functions used throughout
// seed should be in little endian byte order
hash_shake256 : {b , return} (fin b, b >= 1, fin return, return > 0)
             => [b * 8]
             -> [return * 8]
hash_shake256 seed =
  join (SHA3::toBytes (take`{return*8} (SHA3::shake256 (join (SHA3::toBytes seed)))))

// seed should be in little endian byte order
hash_shake128 : {b , return} (fin b, b >= 1, fin return, return > 0)
             => [b * 8]
             -> [return * 8]
hash_shake128 seed =
  join (SHA3::toBytes (take`{return*8} (SHA3::shake128 (join (SHA3::toBytes seed)))))

//ALGORITHM 1
// Generate public and private keys
keygen : [256] -> ([PublicKeyBytes][8], [SecretKeyBytes][8])
keygen s = (pk, sk)
  where
    //H(ξ ,1024)
    rho_rhop_key = hash_shake256`{return = 1024/8} s
    //(ρ,ρ ,K) ∈{0,1}^256×{0,1}^512×{0,1}^256←H(ξ ,1024)
    rho       = take`{256} rho_rhop_key
    rho'      = take`{512} (drop`{256} rho_rhop_key)
    key       = drop`{768} rho_rhop_key
    //Aˆ ←ExpandA(ρ)
    aHat      = expandA rho
    //(s1,s2)←ExpandS(ρ')
    (s1, s2)  = expandS rho'
    //NTT(s1)
    s1Hat     = map ntt s1
    //Aˆ ◦ NTT(s1)
    as1       = map nttInv (nttMatMul aHat s1Hat)
    // t ←NTT−1(Aˆ ◦NTT(s1))+s2
    t         = polyVecAdd as1 s2
    //(t1,t0)←Power2Round(t,d)
    (t1, t0)  = power2RoundPolyVec t
    //pk ←pkEncode(ρ,t1)
    pk        = pkEncode { rho = rho, t1 = t1 }
    //tr ←H(BytesToBits(pk),512)
    tr        = hash_shake256`{return = 512/8} (bytesToBits pk)
    //sk ←skEncode(ρ,K,tr,s1,s2,t0)
    sk        = skEncode { rho = rho
                         , key = key
                         , tr = tr
                         , s1 = s1
                         , s2 = s2
                         , t0 = t0
                         }

// ALGORITHM 2
sign : {mbytes} (fin mbytes, mbytes >= 0)
    => [SecretKeyBytes][8]
    -> [256]
    -> [mbytes*8]
    -> [SigBytes][8]
sign encodedSk rnd m =
  //σ ←sigEncode(c˜,z mod±q,h)
  sigEncode {cTil = finalState.cTil, z = finalState.z, h = h}
  where
    //(ρ,K,tr,s1,s2,t0)←skDecode(sk)
    sk = skDecode encodedSk
    //s1ˆ ←NTT(s1)
    s1Hat   = map ntt sk.s1
    //s2ˆ ←NTT(s2)
    s2Hat   = map ntt sk.s2
    //t0ˆ ←NTT(t0)
    t0Hat   = map ntt sk.t0
    //Aˆ ←ExpandA(ρ)
    aHat   = expandA sk.rho
    //μ ←H(tr||M,512)
    mu    = hash_shake256`{return = 512/8} (sk.tr # m)
    //rnd is the second input to this function
    //ρ′←H(K||rnd||μ,512)
    rho' = hash_shake256`{return = 512/8} (sk.key # rnd # mu)
    //κ ←0
    kappa = 0
    //setting up the inital values for the dowhile loop
    init : SignVarTypes
    init = { z = zero
           , r0 = zero
           , t0Hat = t0Hat
           , cTil = zero
           , cNtt = zero
           , w = zero
           , w1 = zero
           , s1Hat = s1Hat
           , s2Hat = s2Hat
           , cs2 = zero
           , mu = mu
           , rho' = rho'
           , a = aHat
           , kappa = kappa
           }
    //run the dowhile loop on initial state to get final state
    finalState = dowhile signCondition signBody init
    //signCondition will only return a Bit and cannot update ct0 and h
    //if included in type structure so recreate ct0 and h
    ////⟨⟨ct0⟩⟩←NTT−1(cˆ◦ t0ˆ)
    ct0        = map nttInv (nttVecConstMul finalState.cNtt finalState.t0Hat)
    //h ←MakeHint(−⟨⟨ct0⟩⟩,w−⟨⟨cs2⟩⟩+⟨⟨ct0⟩⟩)
    h          = makeHintPolyVec (polyVecSub zero ct0, polyVecAdd (polyVecSub finalState.w
                 finalState.cs2) ct0)

//condition of while loop
signCondition : SignVarTypes -> Bit
signCondition sv = fail1 \/ fail2
  where
    //if ||z||∞ ≥ γ1 −β
    fail1 = (fromZ (infNormPolyVec sv.z) >= fromZ (`GAMMA1 - BETA))
            // or ||r0||∞ ≥ γ2 −β then rerun while loop
            \/ (fromZ (infNormPolyVec sv.r0) >= fromZ ((`GAMMA2 - BETA)))
    //if ||⟨⟨ct0⟩⟩||∞ ≥ γ2
    fail2 = fromZ (infNormPolyVec ct0) >= (`GAMMA2)
            //or the number of 1’s in h is greater than ω then rerun while loop
            \/ (foldl (+) 0 cones) > `OMEGA
    //count the number of ones in h
    cones = sum (map (\x -> (map onesBv (fromZpPoly x))) h)
    //⟨⟨ct0⟩⟩←NTT−1(cˆ◦ t0ˆ)
    ct0   = map nttInv (nttVecConstMul sv.cNtt sv.t0Hat)
    //h ←MakeHint(−⟨⟨ct0⟩⟩,w−⟨⟨cs2⟩⟩+⟨⟨ct0⟩⟩)
    h     = makeHintPolyVec (polyVecSub zero ct0,
            polyVecAdd (polyVecSub sv.w sv.cs2) ct0)

//body of while loop
signBody : SignVarTypes -> SignVarTypes
signBody sv = { z = z
              , r0 = r0
              , t0Hat =sv.t0Hat
              , cTil = cTil
              , cNtt = cNtt
              , w = w
              , w1 = w1
              , s1Hat = sv.s1Hat
              , s2Hat = sv.s2Hat
              , cs2 = cs2
              , mu = sv.mu
              , rho' = sv.rho'
              , a = sv.a
              //κ ←κ +ℓ
              , kappa = (sv.kappa + 1)
              }
  where
    //y ←ExpandMask(ρ' ,κ)
    y   = expandMask (sv.rho', sv.kappa)
    //NTT y
    yNtt  = map ntt y
    //w ←NTT−1(Aˆ ◦NTT(y))
    w   = map nttInv (nttMatMul sv.a yNtt)
    //w1 ←HighBits(w)
    w1  = highBitsPolyVec w
    //c˜ ∈{0,1}^2λ←H(μ||w1Encode(w1),2λ)
    cTil = hash_shake256`{return = 2*LAMBDA/8} (sv.mu # (w1Encode w1))
    //c1˜ ∈{0,1}^256 ← c˜
    c1Til = take`{256} cTil
    //c2˜ ∈{0,1}^2λ-256 ← c˜
    c2Til = drop`{256} cTil
    //c ← SampleInBall(c1˜)
    c = sampleInBall c1Til
    //NTT(c)
    cNtt = ntt c
    //cs1 ← NTT−1(cˆ◦ s1ˆ)
    cs1 = map nttInv (nttVecConstMul cNtt sv.s1Hat)
    //cs2 ← NTT−1(cˆ◦ s2ˆ)
    cs2 = map nttInv (nttVecConstMul cNtt sv.s2Hat)
    //z ←y +⟨⟨cs1⟩⟩
    z   = polyVecAdd y cs1
    //r0 ←LowBits(w −⟨⟨cs2⟩⟩)
    r0 = lowBitsPolyVec (polyVecSub w cs2)

// ALGORITHM 3
verify : { mbytes } (fin mbytes, mbytes >= 0)
      => [PublicKeyBytes][8]
      -> [mbytes * 8]
      -> [SigBytes][8]
      -> Bit
verify encodedPk m encodedSig = crit1 && crit2 && crit3
  where
    //(ρ,t1)←pkDecode(pk)
    pk = pkDecode encodedPk
    //(c˜,z,h)←sigDecode(σ)
    sig = sigDecode encodedSig
    //Aˆ ←ExpandA(ρ)
    aHat = expandA pk.rho
    //tr ←H(BytesToBits(pk),512)
    tr = hash_shake256`{return = 512/8} (bytesToBits encodedPk)
    //μ ←H(tr||M,512)
    mu = hash_shake256`{return = 512/8} (tr # m)
    //c1˜ ∈{0,1}^256 <- c˜
    c1Til = take`{256} sig.cTil
    //c2˜ ∈{0,1}^2λ-256 <- c˜
    c2Til = drop`{256} sig.cTil
    //c ← SampleInBall(c1˜)
    c = sampleInBall c1Til
    //NTT z
    zNtt = map ntt sig.z
    //NTT c
    cNtt  = ntt c
    //t1*2^d
    t1dot2d  = ([[x * (2^^13) | x <- p] | p <- pk.t1])
    //NTT t1*2^d
    t1dot2dNtt = map ntt t1dot2d
    //AHat * NTT (z)
    az       = nttMatMul aHat zNtt
    //NTT (t1*2^d)
    ct1Ntt   = nttVecConstMul (polySub zero cNtt) t1dot2dNtt
    //A * NTT(z) - NTT(c) * NTT(t1*2^d)
    az_ct1Ntt = polyVecAdd az ct1Ntt
    //wApprox' ← NTT^-1(A * NTT(z) - NTT(c) * NTT(t1*2^d))
    wApprox' = map nttInv az_ct1Ntt
    //w ′ ← UseHint(h,wApprox′)
    w1' = useHintPolyVec (sig.h, wApprox')
    //c˜′←H(μ||w1Encode(w1′),2λ)
    cTil' = hash_shake256`{return = 2*LAMBDA/8} (mu # (w1Encode w1'))
    //||z||∞
    zinf     = infNormPolyVec sig.z
    //[ ||z||∞ < γ1 −β]]
    crit1    = (fromZ zinf) < (fromZ (`GAMMA1 - BETA))
    //[[c˜ = c˜′]]
    crit2    = sig.cTil == cTil'
    //count the number of ones in h
    cones    = sum (map (\x -> (map onesBv (fromZpPoly x))) sig.h)
    //[[number of 1’s in h is ≤ ω]]
    crit3    = ( (foldl (+) 0 cones) <= `OMEGA )

dilithiumCorrect : {mbytes} (fin mbytes, mbytes >= 0)
                => [256]
                -> [256]
                -> [mbytes*8]
                -> Bit
property dilithiumCorrect rand1 rand2 mesg = ver
  where
    (pk, sk) = keygen rand1
    sig = sign`{mbytes = mbytes} sk rand2 mesg
    ver = verify`{mbytes = mbytes} pk mesg sig

//counts the number of ones in a polynomial
onesBv : { n } (fin n, n >= 1) => [n] -> [n]
onesBv xs =  l!0
  where
    l = [0] # [ (if xs@i then j + 1 else j):[n] | i <- [ 0..n - 1 ] | j <- l ]

//ALGORITHM 4
//computes the base-2 representation of x mod(2^alpha)
//using little-endian-order
//other ways to do this with cryptol built-ins, but keeping with spec
//alpha is provided as input as a type
integerToBits : {alpha} (fin alpha) => Integer -> [alpha]
integerToBits x = take`{alpha} (join y_arr)
    where
      //compute all the values of x/2
      x_arr = [x] # [xi / 2 | xi <- x_arr]
      //compute all the values of each x mod 2
      y_arr = [fromInteger (xi % 2) : [1] | xi <- x_arr]

//ALGORITHM 5
//computes the integer value expressed by a bit string
//using little endian order
//other ways to do this with cryptol built-ins, but keeping with spec
bitsToInteger : {alpha} (fin alpha, alpha > 0) => [alpha] -> Integer
bitsToInteger  y = x_arr ! 0
  where
    //x ← 2x +y[α −i]
    x_arr = [0] # [ 2 * (toInteger x) + (bitToInt (y @ (`alpha-i)))
                  | x <- x_arr
                  | yi <- y
                  | i <- [1 .. alpha] ]
    //change the bit into Integer type
    bitToInt y' = if y' then 1 else 0

//checks - specifically setting alpha to 10
bitIntegerCorrect : {a} (fin a, a > 0) => Integer -> Bit
property bitIntegerCorrect x =
  if (x > 0) && (x < 2^^10)
  then bitsToInteger (integerToBits`{alpha=a} x) == x
  else True

//ALGORITHM 6
bitsToBytes : {c} (fin c, c > 0) => [c] -> [c/^8][8]
bitsToBytes y = z
  where
    bitToByte : Bit -> [8]
    bitToByte y' = if y' then (zext [1]) else zero
    //add as many zeros at the end as needed
    y_pad : [c/^8][8]
    y_pad = split`{each = 8} (zero # y)
    //rejoin to multiply
    y'' = join y_pad
    //perform all mult at once
    //y[i]*2^(i mod 8)
    y_arr = [bitToByte(y''@i) * 2^^(i % 8) | i <- [0..((c/^8) * 8)-1]]
    //split into the disjoint bytes
    y_split = split`{each = 8} y_arr
    //add all the bits in the byte together
    //z[⌊i/8⌋]←z[⌊i/8⌋]+y[i] · 2^(i mod 8)
    z = [foldl (+) zero yi | yi <- y_split]

//ALGORITHM 7
//trying to keep more with the spec, so not using split and reverse
bytesToBits : {d} (fin d, d > 0) => [d][8] -> [d*8]
bytesToBits z = y
  where
    //for each z[i]
    z_arr' = [z_arr i | i <- [0..d-1]]
    //create an array of all z[i]/2 values
    z_arr i = take`{8} ([z@i] # [zi/2 | zi <- z_arr i])
    //for each z[i], take each z[i]/2 value mod 2, combine into a bit string
    y = join [join [drop`{7} (zi % 2) | zi <- yi] | yi <- z_arr']

//checked
bitsToBytesCorrect : {e} (fin e, e > 0) => [e] -> Bit
property bitsToBytesCorrect b = bytesToBits (bitsToBytes b) == zext b

//ALGORITHM 8
//doing [inf][24] to prevent overflow in [inf][8]
coeffFromThreeBytes : [inf][24] -> [inf][24]
coeffFromThreeBytes randoms = res
  where
    //if b2 > 127 then b2 ←b2 −128 else b2
    b2' = if (b2 > 127)
          then (b2-128)
          else b2
    //z ← 2^16 · b2 + 2^8 · b1 +b0
    z = (2^^16) * b2' + (2^^8) * b1 + b0
    //if z < q then return z else return ⊥
    res  = if z < `Q
          then [z] # (coeffFromThreeBytes tails)
          else (coeffFromThreeBytes tails)
    //take the first three bytes
    [b0, b1, b2] = [randoms@0, randoms@1, randoms@2]
    //drop first three bytes
    tails = drop`{3} randoms

//ALGORITHM 9
//using an inf-list since some values can be null
coeffFromHalfByte : [inf]Integer -> [inf]Integer
coeffFromHalfByte randoms =
  //if η = 2 and b < 15 then return 2−(b mod 5)
  if ((`ETA == 2) && (b < 15))
  then [(2-(b%5))] # (coeffFromHalfByte tails)
  //if η = 4 and b < 9 then return 4 −b
  else if ((`ETA == 4) && (b < 9))
       then [(4-b)] # (coeffFromHalfByte tails)
       //else return ⊥
       else (coeffFromHalfByte tails)
  where
   b = randoms@0
   tails = drop`{1} randoms

//ALGORITHM 10
//not inputting b as a parameter, since only bitlen of b is used
//bitlen of b is provided as type parameter
simpleBitPack : {b} (fin b, b > 0) => Poly -> [32*b][8]
simpleBitPack w = bitsToBytes z //BitsToBytes(z)
  where
    //IntegerToBits(wi,bitlen b)
    zSplit = [integerToBits`{alpha = b} (fromZ wi) | wi <- w]
    //z ← z||IntegerToBits(wi,bitlen b)
    z = join zSplit

//ALGORITHM 11
//not inputting a as a parameter, since only bitlen of ab is used
//bitlen of ab is provided as type parameter
bitPack : {ab} (fin ab, ab > 0) => Poly -> Integer -> [32 * ab][8]
bitPack w b = bitsToBytes z //BitsToBytes(z)
  where
    //IntegerToBits(b −wi,bitlen (a +b))
    zSplit = [integerToBits`{alpha = ab} (b - wi) | wi <- intPoly]
    //z ← z||IntegerToBits(b −wi,bitlen (a +b))
    z = join zSplit
    //change element from (Z Q) to an Integer
    makeInt : (Z Q) -> Integer
    makeInt x  = if (fromZ x) > b then (fromZ x) - `Q else (fromZ x)
    //call makeInt on each element of w
    intPoly = [makeInt pi | pi <- w]

//ALGORITHM 12
//not inputting b as a parameter, since only bitlen of b is used
//c = bitlen b
simpleBitUnpack : {c} (fin c, c > 0) => [32*c][8] -> Poly
simpleBitUnpack v = w
  where
    //z ← BytesToBits(v)
    z = bytesToBits v
    //creating array for each i of (z[ic],z[ic +1],...z[ic +c −1])
    zSplit = split`{each = c} z
    //wi ←BitsToInteger((z[ic],z[ic +1],...z[ic +c −1]),c)
    w = [fromInteger (bitsToInteger`{alpha = c} zi) : (Z Q) | zi <- zSplit]

//checked specifically for t1 values - width of b is 10
simpleBitPackUnpackCorrect : {b, c} (fin b, b > 0, fin c, c> 0) => Poly -> Bit
property simpleBitPackUnpackCorrect p = cond
  where
    cond = if all in_range p
           then simpleBitUnpack`{c=10} (simpleBitPack`{b=10} p) == p
           else True
    in_range : Z Q -> Bit
    in_range c = (fromZ c <= 2^^10)

//ALGORITHM 13
//not inputting a as a parameter, since only bitlen of ab is used
//bitlen of ab is provided as type parameter
bitUnpack : {ab} (fin ab, ab > 0) => [32 * ab][8] -> Integer -> Poly
bitUnpack v b = w
  where
    //z ←BytesToBits(v)
    z = bytesToBits v
    //creating array for each i of (z[ic],z[ic +1],...z[ic +c −1])
    // c = ab
    zSplit = split`{each = ab} z
    //wi ←b −BitsToInteger((z[ic],z[ic +1],...z[ic +c −1]),c)
    w = [ fromInteger (b - (bitsToInteger`{alpha = ab} zi)) : (Z Q)
        | zi <- zSplit ]

//checked specifically for ab = 13 values
bitPackUnpackCorrect : Poly -> Integer -> Bit
property bitPackUnpackCorrect p b = cond
  where
    cond = if all in_range p
           then bitUnpack`{ab=13} (bitPack`{ab=13} p b) b == p
           else True
    in_range : Z Q -> Bit
    in_range c = (fromZ c <= 2^^13)

//ALGORITHM 14
//using PolyVec K instead of [K][256](Z 2)
//this algorithm is more complex for cryptol
//it doesn't look like the spec
hintBitPack : PolyVec K -> [OMEGA + K][8]
hintBitPack h = [fromInteger yi | yi <- y]
  where
    //create an array of the index in place of all the ones
    //if i==0 then the value in the array will be zero
    //going to get rid of all the zeros at the end, so change
    //to 256, which is larger than the number of indexes
    //as this is a byte array, the value will be zero in the end
    findOnesPoly : [256]Integer -> [256]Integer
    findOnesPoly p = [ if pi == 1 then (if i == 0 then 256 else i) else 0
                     | pi <- p
                     | i <- [0..255] ]
    //for each polynomial, find all indices that are one
    findOnesPolyVec: PolyVec K -> [K][256]Integer
    findOnesPolyVec p = [findOnesPoly (toIntPoly pi) | pi <- p]
    //need to take Omega from onefindif however,
    //there may be less than Omega non-zero values in findOnesPolyVec
    //appending [300..399] to end of findOnesPolyVec
    //the values in findOnesPolyVec should never be over 255,
    //so if value is 300 or more, we have gone through the entire input
    //and need to add zeros
    allOnes = join (findOnesPolyVec h) # [300..399]
    //move all indices of one to the front of the array
    findOnesInf : [inf]Integer -> [inf]Integer
    findOnesInf x =
      if (xi != 0) then
        //if under 300, then append value else append 0
        if xi < 300
        then ([xi] # (findOnesInf tails))
        else ([0] # (findOnesInf tails))
      else (findOnesInf tails)
      where
        xi = x@0
        tails = drop`{1} x
    //take Omega of result
    omegaOnes : [OMEGA]Integer
    omegaOnes = take`{OMEGA} (findOnesInf (allOnes # zero))
    //count all the ones in a poly
    sumPoly x = foldl (+) zero x
    //create vec of number of ones in each poly
    sumPolyVec = [sumPoly (toIntPoly hi) | hi <- h]
    //add values so that each value of array is where poly
    //starts in omegaOnes
    indexPoly : [K+1]Integer
    indexPoly = [zero] # [si + i | si <- sumPolyVec | i <- indexPoly]
    y = omegaOnes # (indexPoly@@[1..K])

//ALGORITHM 15
//using PolyVec K instead of [K][256](Z 2)
//this algorithm is more complex for cryptol
//it doesn't look like the spec
hintBitUnpack : [OMEGA + K][8] -> PolyVec K
hintBitUnpack y = [fromIntPoly h | h <- h_arr]
  where
    //change y to Integer array
    yInts : [OMEGA + K]Integer
    yInts = [toInteger yi | yi <- y]
    //get the indices for each polynomial
    yIndices : [K]Integer
    yIndices = drop`{OMEGA} yInts
    //find the last index of a 1 in each polynomial
    lastOne : [K]Integer
    lastOne = [if ind > 0 then (yInts@(ind-1)) else 0 | ind <- yIndices]
    //count the number of ones in each polynomial
    //find the difference between indices
    y0 : [K+1]Integer
    y0 = zero # yIndices
    countOnes : [K]Integer
    countOnes = [(y0@i - y0@(i-1)) | i <- [1..K]]
    //drop the indices at the end of packedH
    yDropIndices : [OMEGA]Integer
    yDropIndices = take`{OMEGA} yInts
    //create an array of all the possible indices for each poly
    //if the index is larger that the index of the last zero then
    //use 300 in the count array so none of the values (which are 0 to 255)
    //will equal the count - helps prevent issues that might occur with zero
    //if there are no ones in the polynomial set all values to 300
    count_arr : [256*K]Integer
    count_arr = join [ [ if ni == 0
                         then 300
                         else if i > li
                              then 300
                              else i
                        | i <- [0..255] ]
                     | j <- [1..K]
                     | ni <- countOnes
                     | li <- lastOne ]
    //expand yDropIndices into [256*K]Integer
    value_arr : [256*K]Integer
    value_arr = yDropIndices # zero
    //combine the count array and value_array into pairs
    combined : [256*K](Integer, Integer)
    combined = [(ti, ci) | ti <- value_arr | ci <- count_arr]
    //function to add zeros to array in the correct places
    reZero : [inf](Integer, Integer) -> [inf](Integer, Integer)
    reZero p =
      if value == count
      //put 1 if the index should have a one
      then [(1, count)] # reZero tails
      //put a 0 otherwise
      else ([(0, count)] # reZero new_p)
      where
        //get first (value, count)
        first = p@0
        value = first.0
        count = first.1
        //create the tail
        tails = drop`{1} p
        //increase the count, but keep the value the same
        //used for next iteration if not at correct index
        values = [pi.0 | pi <- p]
        counts = [pi.1 | pi <- p]
        //increment the count
        drop_count = drop`{1} counts
        //recombine for the right type
        new_p = [(vi, ci) | vi <- values | ci <- drop_count]
    //use the function to add zeros to array in the correct places
    //take only K*256 values
    reZeroed : [K*256](Integer, Integer)
    reZeroed = take`{K*256} (reZero (combined # zero))
    //get h array values with zeros, split into K
    h_arr : [K][256]Integer
    h_arr = split`{parts=K} [hi.0 | hi <- reZeroed]

//checks 1000 tests, not sure if actually finding a value though
//polynomials filled with either 0 or 1, so using (Z 2) instead of (Z Q)
hintBitPackUnpackCorrect : [K][256](Z 2) -> Bit
property hintBitPackUnpackCorrect polyVec = result
  where
    //change from (Z 2) to (Z Q) so right type for hintBitPack
    changeZ : (Z 2) -> (Z Q)
    changeZ z = fromInteger (fromZ z) : (Z Q)
    //call changeZ on each value in Poly
    changeZPoly : [256](Z 2) -> Poly
    changeZPoly p = [changeZ pi | pi <- p]
    //call changeZPoly on each poly in PolyVec
    changeZPolyVec : [K][256](Z 2) -> PolyVec K
    changeZPolyVec pv = [changeZPoly pvi | pvi <- pv]
    //change the input polyVec
    z2PolyVec = changeZPolyVec polyVec
    //count all the ones in a poly
    sumPoly x = foldl (+) zero x
    //create vec of number of ones in each poly
    sumPolyVec = [sumPoly (toIntPoly hi) | hi <- z2PolyVec]
    //sum all the values from sumPolyVec to get the total
    //number of ones in the polyVec
    totalOnes = [0] # [si + ti | si <- sumPolyVec | ti <- totalOnes]
    //the polyVec has at most Omega 1, so if the number of ones is more
    //discard the polynomail
    result = if (totalOnes ! 0) > `OMEGA
             then True
             else (hintBitUnpack (hintBitPack z2PolyVec) == z2PolyVec)


//change zp_poly to int_poly
toIntPoly : Poly -> [256]Integer
toIntPoly p = [fromZ pi | pi <- p]

//change int_poly to zp_poly
fromIntPoly : [256]Integer -> Poly
fromIntPoly p = [fromInteger pi | pi <- p]

//ALGORITHM 16
pkEncode : PublicKey -> [PublicKeyBytes][8]
pkEncode pk = packedPk
  where
    //pk ← BitsToBytes(ρ)
    pk' = bitsToBytes pk.rho
    //SimpleBitPack(t1, 2^(bitlen(q-1)-d)-1)
    packedT1 = [simpleBitPack`{width(2^^(width(Q-1)-D)-1)} (ti) | ti <- pk.t1]
    //pk ← pk || SimpleBitPack(t1, 2^(bitlen(q-1)-d)-1)
    packedPk = pk' # (join packedT1)

//ALGORITHM 17
pkDecode : [PublicKeyBytes][8] -> PublicKey
pkDecode pk = {rho = rho, t1 = t1}
  where
    //ρ ←BytesToBits(y)
    rho = bytesToBits (take`{32} pk)
    //(B^(32*(bitlen(q-1)-d)))^k
    z = split`{parts = K} (drop`{32} pk)
    //t1[i] ← SimpleBitUnpack(zi, 2^(bitlen(q-1)-d)-1)
    t1 = [simpleBitUnpack`{width(2^^(width(Q-1)-D)-1)} zi | zi <- z]

//checked
pkEncodeDecodeCorrect : PublicKey -> Bit
property pkEncodeDecodeCorrect pk =
    if all check_t1 pk.t1 then pkDecode (pkEncode pk) == pk else True
    where
      // For each t1 polynomial, run check_c on all of the coefficients
      check_t1 : Poly -> Bit
      check_t1 c = all check_c c
      // Check if each coefficient of the polynomial is 10 bits or less
      check_c : Z Q -> Bit
      check_c c1 = if (fromZ c1 <= 2^^10) then True else False

//ALGORITHM 18
skEncode : SecretKey -> [SecretKeyBytes][8]
skEncode sk = packedSk
  where
    //sk ← BitsToBytes(ρ) || BitsToBytes(K) || BitsToBytes(tr)
    sk' = (bitsToBytes sk.rho) # (bitsToBytes sk.key) # (bitsToBytes sk.tr)
    //BitPack (s1[i],η,η)
    s1Packed = join [bitPack`{ab = width(2*ETA)} s1i `ETA | s1i <- sk.s1]
    //BitPack (s2[i],η,η)
    s2Packed = join [bitPack`{ab = width(2*ETA)} s2i `ETA | s2i <- sk.s2]
    //BitPack (t0, 2^(d-1)-1, 2^(d-1))
    t0Packed = join [ bitPack`{ab = width(2^^(D-1)-1+2^^(D-1))} t0i (2^^(`D-1))
                    | t0i <- sk.t0]
    //sk ← sk
    //  || BitPack (s1[i],η,η)
    //  || BitPack (s2[i],η,η)
    //  || BitPack (t0, 2^(d-1)-1, 2^(d-1))
    //
    packedSk = sk' # s1Packed # s2Packed # t0Packed

//ALGORITHM 19
skDecode: [SecretKeyBytes][8] -> SecretKey
skDecode sk = {rho=rho, key=key, tr=tr, s1=s1, s2=s2, t0=t0}
  where
    //ρ ←BytesToBits(f)
    rho = bytesToBits(sk@@[0..31])
    //K ←BytesToBits(g)
    key = bytesToBits(sk@@[32..63])
    //tr ←BytesToBits(h)
    tr = bytesToBits(sk@@[64..127])
    //remove rho, key, tr bits
    yzw = drop`{128} sk
    //get y
    y = take`{L*32*width(2*ETA)} yzw
    //create yi
    ySplit = split`{parts = L} y
    //s1[i]←BitUnpack(yi,η,η)
    s1 = [bitUnpack`{ab = width(2*ETA)} yi `ETA | yi <- ySplit]
    //remove y bits
    zw = drop`{L*32*width(2*ETA)} yzw
    //get z
    z = take`{K*32*width(2*ETA)} zw
    zSplit = split`{parts = K} z
    //s2[i]←BitUnpack(zi,η,η)
    s2 = [bitUnpack`{ab = width(2*ETA)} zi `ETA | zi <- zSplit]
    //get w
    w = drop`{K*32*width(2*ETA)} zw
    wSplit = split`{parts = K} w
    //t0[i]←BitUnpack (t0, 2^(d-1)-1, 2^(d-1))
    t0 = [ bitUnpack`{ab = width(2^^(D-1)-1+2^^(D-1))} wi (2^^(`D-1))
         | wi <- wSplit ]

// passed 1000 tests, prove takes longer
skEncodeDecodeCorrect: SecretKey -> Bit
property skEncodeDecodeCorrect x =
  if (all check_s x.s1) && (all check_s x.s2) && (all check_t0 x.t0)
  then skDecode (skEncode x) == x else True
    where
      // For each t0 polynomial, run check_t0_c on all of the coefficients
      check_t0 : Poly -> Bit
      check_t0 c = all check_t0_c c
      // Check if each coefficient of the t0 polynomial is 13 bits or less
      check_t0_c : Z Q -> Bit
      check_t0_c c1 = if (fromZ c1 <= 2^^13) then True else False
      // For each s polynomial, run check_s_c on all of the coefficients
      check_s : Poly -> Bit
      check_s c = all check_s_c c
      // Check if each coefficient of the s polynomial is in range [-ETA, ETA]
      check_s_c : Z Q -> Bit
      check_s_c c1 = (fromZ c1 <= `ETA) \/ (fromZ c1 >= (`Q - `ETA))

//ALGORITHM 20
sigEncode : SigTypes -> [SigBytes][8]
sigEncode sig = cPacked # (join zPacked) # hPacked
  where
    //BitsToBytes(c˜)
    cPacked = bitsToBytes`{c=2*LAMBDA} (sig.cTil)
    //BitPack (z[i],γ1 −1,γ1)
    zPacked = [bitPack`{ab = width(2*GAMMA1 - 1)} zi `GAMMA1 | zi <- sig.z]
    //HintBitPack (h)
    hPacked = hintBitPack sig.h

//ALGORITHM 21
sigDecode : [SigBytes][8] -> SigTypes
sigDecode sigBytes = {cTil = cTil, z = z, h = h}
  where
    //c˜ ←BytesToBits(w)
    cTil = bytesToBits (take`{LAMBDA/4} (sigBytes))
    xy = drop`{LAMBDA/4} sigBytes
    x = take`{L*32*(1+width(GAMMA1-1))} xy
    //split into polynomials
    zSplit = split`{parts = L} x
    //BitUnpack(xi,γ1 −1,γ1)
    z = [bitUnpack`{ab = width(2*GAMMA1-1)} zi `GAMMA1 | zi <- zSplit]
    y = drop`{L*32*(1+width(GAMMA1-1))} xy
    //h ←HintBitUnpack(y)
    h = hintBitUnpack y

//sigTypes modified to only allow h to be in (Z 2) instead of (Z Q)
//for random testing purposes
sigEncodeDecodeCorrect : { cTil : [2*LAMBDA], z : PolyVec L, h : [K][256](Z 2)}
                      -> Bit
property sigEncodeDecodeCorrect sig = result
  where
    //check that the h is properly generated
    changeZ : (Z 2) -> (Z Q)
    changeZ z = fromInteger (fromZ z) : (Z Q)
    //call changeZ on each value in Poly
    changeZPoly : [256](Z 2) -> Poly
    changeZPoly p = [changeZ pi | pi <- p]
    //call changeZPoly on each poly in PolyVec
    changeZPolyVec : [K][256](Z 2) -> PolyVec K
    changeZPolyVec pv = [changeZPoly pvi | pvi <- pv]
    //change the input polyVec
    z2PolyVec = changeZPolyVec sig.h
    //count all the ones in a poly
    sumPoly x = foldl (+) zero x
    //create vec of number of ones in each poly
    sumPolyVec = [sumPoly (toIntPoly hi) | hi <- z2PolyVec]
    //sum all the values from sumPolyVec to get the total
    //number of ones in the polyVec
    totalOnesH = [0] # [si + ti | si <- sumPolyVec | ti <- totalOnesH]
    //the polyVec has at most Omega 1, so if the number of ones is more
    //discard the polynomail
    result = if (totalOnesH ! 0) > `OMEGA
             then True
             else (sigDecode (sigEncode { cTil = sig.cTil
                                        , z = sig.z
                                        , h = (changeZPolyVec sig.h)})
               == { cTil = sig.cTil, z = sig.z, h = (changeZPolyVec sig.h)})

//ALGORITHM 22
w1Encode : PolyVec K -> [W1Packed*8]
w1Encode w1 = join w1Til
  where
    //BytesToBits (SimpleBitPack (w1[i],(q −1)/(2γ2)−1))
    w1Til =
      [ bytesToBits(simpleBitPack`{b = (width ((Q - 1)/(2*GAMMA2 - 1)))} w1i)
      | w1i <- w1 ]

//ALGORITHM 23
sampleInBall : [256] -> Poly
sampleInBall seed = cs ! 0
  where
    //returning a large value from shake, since return can't be inf
    hashValues = (split`{each = 8} (hash_shake256`{return = 1000} seed))
    //array of all K values after going through increment K while loop
    //appending zero to hash for inf list k should be 8, but initial setting as
    //7 since immediately adding 1 to it when calling while loop
    incKs = [(hashValues # zero, 7, 0)] # [ incK (p.0, (p.1+1), i)
                                          | p <- incKs
                                          | i <- [(256-TAU)..255] ]
    //get just the K values from incKs
    //remove the k=7 value
    ks = drop`{1} [ika.1 | ika <- incKs]
    //create an array of all the js : j ← H(ρ)[[k]]
    js = [hashValues @ ki | ki <- ks]
    //create an array of all the sign values : H(ρ)[i+τ−256]
    ss = [(join hashValues)@(i+`TAU-256) | i<- [(256-TAU)..255]]
    //create the c polynomial
    cs = [ zero:Poly ] #
         //if s==1 then (-1)^1 = -1 so update so ci=cj and cj=-1
         //else (-1)^0 = 1 so update so ci=cj and cj=1
         [ if s==1
           then (updates c [j,i] [(-1 : (Z Q)),c@j])
           else (updates c [j,i] [1,c@j])
         | c <- cs
         | i <- [(256-TAU)..255]
         | j <- js
         | s <- ss ]

//cond of while loop - checks if H(ρ)[[k]] > i
incKCond : ([inf][8], Integer, Integer) -> Bit
incKCond(hashValues, k, i) =  (toInteger (hashValues@k)) >  i

//body of while loop -- increments k
incKBody : ([inf][8], Integer, Integer) -> ([inf][8], Integer, Integer)
incKBody (hashValues, k, i) = (hashValues, k+1, i)

//while loop to increase k if H(ρ)[[k]] > i
incK : ([inf][8], Integer, Integer) -> ([inf][8], Integer, Integer)
incK (hashValues, k, i) = while incKCond incKBody (hashValues, k, i)

//ALGORITHM 24
rejNTTPoly : [272] -> Poly
rejNTTPoly rho = take`{256} aHats_Zq
  where
    //can't take inf amount in order to use toBytes, so taking large number
    randoms = split`{each = 8} (hash_shake128`{return=10000} rho)
    //zext so each random is [24] instead of [8]
    randoms_zext = [zext r : [24] | r <- randoms]
    //appending randoms with zero to get [inf][24]
    //aHat[j] = CoeffFromThreeBytes
    aHats = coeffFromThreeBytes (randoms_zext # zero)
    //changing aHats to elements of (Z Q)
    aHats_Zq = [fromInteger (toInteger aH) : (Z Q) | aH <- aHats]

//ALGORITHM 25
rejBoundedPoly : [528] -> Poly
rejBoundedPoly seed  = aZqPoly
  where
    //toBytes can't have an if list, so taking a very large number instead
    //z ←H(ρ)[[c]] - doing all cs at once
    zs = split`{each = 8} (hash_shake256`{return = 10000} seed)
                # zero //spliting into bytes -> [[c]]
    //changing zs to integers
    zsInts = [toInteger zi | zi <- zs]
    //calculate an array with all the z0s and z1s - none will be null
    z0s_z1s = coeffFromHalfByte (join [[zi % 16, zi / 16] | zi <- zsInts])
    //taking 256 coeffs needed for polynomial
    aIntPoly = take`{256} z0s_z1s
    //changing a from [256]Integer to [256](Z Q)
    aZqPoly = [(fromInteger ai) : (Z Q) | ai <- aIntPoly]

//ALGORITHM 26
expandA : [256] -> [K][L]NttPoly
expandA rho = a
  where
    //for r from 0 to k −1 do
    //for s from 0 to ℓ−1 do
    //Aˆ [r,s]←RejNTTPoly(ρ||IntegerToBits(s,8)||IntegerToBits(r,8))
    a = [ [ rejNTTPoly ( rho
                       # (integerToBits`{alpha = 8} s)
                       # (integerToBits`{alpha = 8} r))
          | s <- [0..(L - 1)] ]
        |  r <- [0..(K - 1)] ]

//ALGORITHM 27
//sample vectors s1 and s2 in [-eta, eta]
expandS : [512] -> (PolyVec L, PolyVec K)
expandS rho = (s1, s2)
  where
    //for r from 0 to ℓ−1 do
    //s1[r]←RejBoundedPoly(ρ||IntegerToBits(r,16))
    s1 = [ rejBoundedPoly(rho # (integerToBits`{alpha = 16} r))
         | r <- [0..L-1]]
    //r r from 0 to k −1 do
    //s2[r]←RejBoundedPoly(ρ||IntegerToBits(r +ℓ,16))
    s2 = [ rejBoundedPoly(rho # (integerToBits`{alpha = 16} (r+`L)))
         | r <- [0..K-1]]

//ALGORITHM 28
/*Vadim Lyubashevsky left the following note on the PQC Forum:
The ExpandMask function (Algorithm 28) already uses a different
input for SHAKE for every polynomial. It should thus use the output
from the beginning of the hash stream and not start at an offset
(i.e. the r is not needed in the expansion in line 4).

ExpandMask as written in the final draft is difficult to code in
Cryptol because of the offset. This ExpandMask function below ignores
the offset, as Vadim has pointed out it is unnecessary*/
expandMask : ([512], Integer) -> PolyVec L
expandMask (rho, mu) = s
  where
    //c←1 +bitlen (γ1 −1)
    type c = 1+width(GAMMA1-1)
    //n ←IntegerToBits(μ +r,16) - this is an array of all the n values
    n = [integerToBits`{alpha=16} (mu+ri) | ri <- [0..L-1]]
    //v ←(H(ρ||n)[[0]],H(ρ||n)[[1]],...,H(ρ||n)[[32*c-1]])
    v = [split`{each = 8} (hash_shake256`{return = 32*c} (rho # ni)) | ni <- n]
    //s[r]←BitUnpack(v,γ1 −1,γ1)
    s = [bitUnpack`{width(2*GAMMA1 - 1)} vi `GAMMA1 | vi <- v]

//ALGORITHM 29
power2Round : (Z Q) -> ((Z Q),(Z Q))
power2Round r = (r1, r0)
  where
    //r+ ←r mod q - r already mod q since in (Z Q)
    rPlus = r
    //r0←r^+mod±2^d
    r0 = centeredMod r (2^^`D)
    //(r^+−r0)/2^d
    r1 = fromInteger ((fromZ (rPlus - r0))/2^^`D) : (Z Q)

//function to perform power2round on each value in a polynomial
polyPower2Round : {m} [m](Z Q) -> ([m](Z Q), [m](Z Q))
polyPower2Round p = unzip [ power2Round r | r <- p ]

//function to perform power2round on each polynomial
//in a vector of polynomials
power2RoundPolyVec : {dim} (fin dim, dim >= 1) => PolyVec dim -> ([dim]Poly,[dim]Poly)
power2RoundPolyVec v = unzip (map polyPower2Round v)

//function that computes the value of x1 centered around mod n1
//values returned in mod q
centeredMod : (Z Q) -> (Z Q) -> (Z Q)
centeredMod x1 n1 = fromInteger (if r > (n / 2) then r - n else r)
  where
    x = fromZ x1
    n = fromZ n1
    r = x % n

//ALGORITHM 30
decompose : (Z Q) -> ((Z Q),(Z Q))
decompose r = result
  where
    //r+ ←r mod q - r already mod q since in (Z Q)
    rPlus = r
    //r0 ←r^+ mod±(2γ2)
    r0 = centeredMod rPlus (2*`GAMMA2)
    //if r^+ − r0 = q −1
    result = if (rPlus - r0) == (fromInteger (`Q-1) : (Z Q))
              //then r1 ←0, r0 ←r0 −1
              then (0, r0 - 1)
              //else r1 ←(r^+−r0)/(2γ2)
              else (fromInteger (fromZ (rPlus - r0)/ (2*`GAMMA2)), r0)

//ALGORITHM 31
highBits : (Z Q) -> (Z Q)
highBits r = r1
  where
    //(r1,r0)←Decompose(r)
    (r1, r0) = decompose r

//run highBits on each element in the poly
highBitsPoly : Poly -> Poly
highBitsPoly p = [highBits pi | pi <- p]

//run highBitsPoly on each poly in the polyVec
highBitsPolyVec : PolyVec K -> PolyVec K
highBitsPolyVec pv = [highBitsPoly pvi | pvi <- pv]

//ALGORITHM 32
lowBits : (Z Q) -> (Z Q)
lowBits r = r0
  where
    //(r1,r0)←Decompose(r)
    (r1, r0) = decompose r

//run lowBits on each element in the poly
lowBitsPoly : Poly -> Poly
lowBitsPoly p = [lowBits pi | pi <- p]

//run lowBitsPoly on each poly in the polyVec
lowBitsPolyVec : PolyVec K -> PolyVec K
lowBitsPolyVec pv = [lowBitsPoly pvi | pvi <- pv]

//ALGORITHM 33
makeHint : ((Z Q),(Z Q)) -> (Z Q)
makeHint (z, r) = if r1 != v1 then 1 else 0 //[[r1 = v1]]
  where
    //r1 ←HighBits(r)
    r1 = highBits r
    //v1 ←HighBits(r +z)
    v1 = highBits (r+z)

//run makeHint on each element in the poly
makeHintPoly : (Poly, Poly) -> Poly
makeHintPoly (zp, rp) = [makeHint (z, r) | z <- zp | r <- rp ]

//run makeHintPoly on each poly in the polyVec
makeHintPolyVec : { n } (fin n, n >= 1) => (PolyVec n, PolyVec n) -> PolyVec n
makeHintPolyVec (zv, rv) =  [ makeHintPoly (zp, rp) | zp <- zv | rp <- rv ]

//ALGORITHM 34
useHint : ((Z Q), (Z Q)) -> (Z Q)
useHint (h,r) = return
  where
    //m ←(q−1)/(2γ2)
    m = (`Q-1) / (2*`GAMMA2)
    //(r1,r0)←Decompose(r)
    (r1, r0) = decompose r
    //since the values of r0 are mod q, if they are
    //"positive" then they will be < (`Q-1)/2
    //and "negative" values will be  >= (`Q-1)/2
             //if h = 1 and r0 > 0
    return = if (((fromZ h) == 1) && ((fromZ r0) < ((`Q-1)/2)))
             //return (r1 +1) mod m
             then (fromInteger (((fromZ r1) + 1) % m))
             //if h = 1 and r0 ≤ 0
             else if (((fromZ h) == 1) && ((fromZ r0) >= ((`Q-1)/2)))
                  //return (r1 −1) mod m
                  then (fromInteger (((fromZ r1) - 1) % m))
                  else r1

//run useHint on each element in the poly
useHintPoly : Poly -> Poly -> Poly
useHintPoly hp rp = [ useHint (h, r) | r <- rp | h <- hp ]

//run useHintPoly on each poly in the polyVec
useHintPolyVec : (PolyVec K, PolyVec K) -> PolyVec K
useHintPolyVec (hv,rv) = [ useHintPoly hp rp | hp <- hv | rp <- rv]

//ALGORITHM 35
//This cryptol code was not changed from the round 3 version
//The round 3 ntt cryptol code matched the C reference implementation
ntt : Poly -> NttPoly
ntt p = nttp
  where
    r k = ROOTOFUNITY ^^ k  //mod_pow(`Q, ROOTOFUNITY, k)
    exponents = join [ [ zext`{m = 9} i, (256 + (zext`{m = 9} i))]
                     | i <- [reverse ((128+i) : [8]) | i <- [0..127]]
                     ]
    nttp = [ multipleSum [ (p@idx) * ((r k) ^^ i)
                         | idx<-[0..(N-1)]:[N][width N]
                         | i<-[0..(N-1)]:[N][QBits]
                         ]
           | k <- exponents
           ]

//ALGORITHM 36
//This cryptol code was not changed from the round 3 version
//The round 3 nttInv cryptol code matched the C reference implementation
nttInv : [N](Z Q) -> [N](Z Q)
nttInv p' = p
  where
    pu = reorder p'
    r' i = ROOTOFUNITYINV ^^ (i * 2) //mod_pow (`Q, ROOTOFUNITYINV, i * 2)
    p = [ NINV
        * ROOTOFUNITYINV ^^ i
        * (multipleSum [(pu@jdx) * (r' ((i*j)))
                       | jdx <- [0..(N-1)]:[N][width N]
                       | j <- [0..(N-1)]:[N][QBits]
                       ])
        | i <- [0..(N-1)]:[N][QBits]
        ]

//property to verify NTT is correct
//check
nttCorrect : Poly -> Bit
property nttCorrect f =  nttInv (ntt f) == f

// ------ NTT Functions -------
// Sum values in array in Z Q
multipleSum : { m } (fin m) => [m](Z Q) -> (Z Q)
multipleSum l = sums!0
  where
    sums = [ zero ] # [ x + y | x <- l | y <- sums ]

// Dilithium uses a non-standard ordering of elements in the NTT domain;
// this function reorders the elements.
reorder : NttPoly -> NttPoly
reorder a = join [ [ a1@i, a2@i ] | i <- [0..127]:[_][8] ]
  where
    a1 = a@@[ (i - 1)/2
            | i <- [ reverse ((128 + i) : [8]) | i <- [0..127] ]
            ]
    a2 = reverse (a@@[ (511 - (zero#i):[9])/2
                     | i <- [ reverse ((128 + i) : [8]) | i <- [0..127] ]
                     ])

// --- Operations on NTT polynomials
// Operations on NTT polynomials
nttMatMul : { dim1, dim2 } (fin dim1, fin dim2)
         => NttMat dim1 dim2 -> NttVec dim2 -> NttVec dim1
nttMatMul mat vec = [ nttDotProduct v vec | v <- mat ]

nttDotProduct : { dim } (fin dim) => NttVec dim -> NttVec dim -> NttPoly
nttDotProduct v1 v2 =
  foldl polyAdd (zero:NttPoly) [ nttPolyMult p1 p2 | p1 <- v1 | p2 <- v2 ]

nttPolyMult : NttPoly -> NttPoly -> NttPoly
nttPolyMult p1 p2 = [ x * y | x <- p1 | y <- p2 ]

nttVecConstMul : { dim } (fin dim) => NttPoly -> NttVec dim -> NttVec dim
nttVecConstMul c v = map (nttPolyMult c) v

// Add polynomials
polyAdd : Poly -> Poly -> Poly
polyAdd p1 p2 = [ x + y | x <- p1 | y <- p2 ]

polyVecAdd : { dim } (fin dim) => PolyVec dim -> PolyVec dim -> PolyVec dim
polyVecAdd v1 v2 = zipWith polyAdd v1 v2

// Subtract polynomials
polySub : Poly -> Poly -> Poly
polySub p1 p2 = [ x - y | x <- p1 | y <- p2 ]

polyVecSub : { dim } (fin dim) => PolyVec dim -> PolyVec dim -> PolyVec dim
polyVecSub v1 v2 = zipWith polySub v1 v2

// Aux functions
infNorm : (Z Q) -> (Z Q)
infNorm x = if (fromZ x) > (`Q-1)/2
            then fromInteger (`Q - (fromZ x)) : (Z Q)
            else x

infNormPoly : Poly -> (Z Q)
infNormPoly p =
  fromInteger (toInteger (foldl max 0 (fromZpPoly (map infNorm p)))) : (Z Q)

infNormPolyVec : { dim } (fin dim, dim >= 1) => PolyVec dim -> (Z Q)
infNormPolyVec v = fromInteger (toInteger (foldl max 0 m')) : (Z Q)
  where
    m = (map infNormPoly v)
    m' = [(fromZ mp) | mp <- m]

//convert between polynomial types
fromZpPoly : [N](Z Q) -> [N][QBits]
fromZpPoly zp_poly = [(fromInteger (fromZ p)) : [23] | p <- zp_poly]

toZpPoly : [N][23] -> [N](Z Q)
toZpPoly q_poly = [(fromInteger (toInteger q)) : (Z Q) | q <- q_poly]
