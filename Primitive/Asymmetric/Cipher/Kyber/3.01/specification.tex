%!TEX root=./kyber.tex

\NISTdescription{A complete written specification of the algorithms shall be included, consisting of all necessary mathematical operations, equations, tables, and diagrams that are needed to implement the algorithms.}

\NISTdescription{Each submission package shall describe a collection of algorithms, also called a cryptosystem or cryptographic scheme, that implements one or more of the following functionalities: public-key encryption, key encapsulation mechanism (KEM), and digital signature. Public-key encryption schemes shall include algorithms for key generation, encryption, and decryption. KEM schemes shall include algorithms for key generation, encapsulation, and decapsulation. Digital-signature schemes shall include algorithms for key generation, signature generation and signature verification.}

\NISTdescription{If a submission includes more than one type of scheme, NIST will evaluate the schemes of each type separately.  Submitters may choose to combine different types of schemes into a single submission.  They may also instead prepare and submit a complete submission package for each algorithm, making sure to include all supporting documents and intellectual property statements in each individual package.}

\NISTdescription{As the KEM and public-key encryption functionalities can generally be interconverted, unless the submitter specifies otherwise, NIST will apply standard conversion techniques to convert between schemes if necessary.}

\NISTdescription{The document shall also include a design rationale, and an explanation for all the important design decisions that have been made.}

\NISTdescription{For algorithms that have tunable parameters (such as the dimension of some underlying vector space, or the number of equations and variables), the submission document shall specify concrete values for these parameters. If possible, the submission should specify several parameter sets that allow the selection of a range of possible security/performance trade-offs. In addition, the submitter should provide an analysis of how the security and performance of the algorithms depend on these parameters. To facilitate the analysis of these algorithms by the cryptographic community, submitters are encouraged to also specify parameter sets that provide lower security levels, and to provide concrete examples that demonstrate how certain parameter settings affect the feasibility of known cryptanalytic attacks.}

\NISTdescription{Specific parameter sets may permit NIST to select a different performance/security trade-off than originally specified by the submitter, in light of discovered attacks or other analysis, and in light of the alternative algorithms that are available. NIST will consult with the submitter of the algorithm, as well as the cryptographic community, if it plans to select that algorithm for development as a NIST standard, but with a different parameter set than originally specified by the submitter.}

\NISTdescription{A complete submission shall specify any padding mechanisms and any uses of NIST-approved cryptographic primitives that are needed in order to achieve security. If the scheme uses a cryptographic primitive that has not been approved by NIST, the submitter shall provide an explanation for why a NIST-approved primitive would not be suitable.}


\begin{code}
  module specification where
\end{code}


\Kyber is an IND-CCA2-secure key-encapsulation mechanism (KEM),
which has first been described in~\cite{BDK+18}.
The security of \Kyber is based on the hardness of solving the learning-with-errors
problem in module lattices (MLWE problem~\cite{DCC:LS15}). 
The construction of \Kyber follows a two-stage approach: we first introduce
an IND-CPA-secure public-key encryption scheme encrypting messages of a fixed length of 32 bytes, 
which we call \KyberCPAPKE. We then use a slightly tweaked Fujisaki--Okamoto (FO) 
transform~\cite{C:FujOka99} to construct the IND-CCA2-secure KEM. 
Whenever we want to emphasize that we are speaking about the IND-CCA2-secure KEM, 
we will refer to it as \KyberCCAKEM. 

In Subsection~\ref{subsec:specification:prelim} we give preliminaries and fix notation.
In Subsection~\ref{subsec:specification:cpaenc} we give a full specification of \KyberCPAPKE.
Subsection~\ref{subsec:specification:ccakem} gives details of the transform that we use in \Kyber
to obtain \KyberCCAKEM from \KyberCPAPKE.
Subsection~\ref{subsec:specification:params} lists the parameters that we propose for different security levels.


\subsection{Preliminaries and notation.}
\label{subsec:specification:prelim}


\subheading{Bytes and byte arrays.}
Inputs and outputs to all API functions of \Kyber are byte arrays.
To simplify notation, we denote by \Bytes the set $\{0,\dots,255\}$, i.e., 
the set of $8$-bit unsigned integers (bytes). 
Consequently we denote by $\Bytes^k$ the set of byte arrays of length $k$
and by $\Bytes^*$ the set of byte arrays of arbitrary length (or byte streams).
For two byte arrays $a$ and $b$ we denote by $(a\cat b)$ the concatenation
of $a$ and $b$.
For a byte array $a$ we denote by $a+k$ the byte array
starting at byte $k$ of $a$ (with indexing starting at zero).
For example, let $a$ by a byte array of length $\ell$, let $b$
be another byte array and let $c = (a\cat b)$ be the concatenation
of $a$ and $b$; then $b = a+\ell$.
When it is more convenient to work with an array of bits than an
array of bytes we make this conversion explicit via the $\mathsf{BytesToBits}$ 
function that takes as input an array of $\ell$ bytes and produces as
output an array of $8\ell$ bits. Bit $\beta_i$ at position $i$ of the output bit array 
is obtained from byte $b_{i/8}$ at position $i/8$ of the input array
by computing $\beta_i = \left((b_{i/8} / 2^{(i\mod 8)}) \mod 2\right)$.

\begin{code}
  type Byte = [8]

  BytesToBits : {ell} (fin ell, ell > 0) => [ell]Byte -> [ell*8]Bit
  BytesToBits input = [ (input@(i/8))@(i%8) | i <- [0 .. (ell*8-1)]]
  
  BitToZ : {p} (fin p, p > 1) => Bit -> Z p
  BitToZ b = if b then 1 else 0
  
  plus : {x, y} (fin x) => [x+y]Byte -> [y]Byte
  plus = drop

  // Cryptol's built-in operator for concatenation is #
  concatPlus : {x, y} (fin x, fin y) => [x]Byte -> [y]Byte -> [y]Byte
  concatPlus a b = plus`{x} (a#b)
  
  concatPlusCorrect : {x, y} (fin y, fin x) => [x]Byte -> [y]Byte -> Bit
  property concatPlusCorrect a b = concatPlus a b == b
\end{code}
\subheading{Polynomial rings and vectors.}
We denote by $R$ the ring $\Z[X]/(X^{n}+1)$ and by $R_q$ the ring $\Z_q[X]/(X^{n}+1)$, 
where $n=2^{n'-1}$ such that $X^{n}+1$ is the $2^{n'}$-th cyclotomic polynomial. 
Throughout this document, the values of $n$, $n'$ and $q$ are fixed to $n=256$, $n'=9$, and $q=3329$.
Regular font letters denote elements in $R$ or $R_q$ (which includes elements in $\Z$ and $\Z_q$) 
and bold lower-case letters represent vectors with coefficients in $R$ or~$R_q$.  
By default, all vectors will be column vectors. Bold upper-case letters are matrices. 
For a vector $\vpo$ (or matrix $\Apo$), we denote by $\vpo^T$ (or~$\Apo^T$) its transpose.
For a vector $\vpo$ we write $\vpo[i]$ to denote it's $i$-th entry (with indexing starting at zero);
for a matrix $\Apo$ we write $\Apo[i][j]$ to denote the entry in row $i$, column $j$ 
(again, with indexing starting at zero).

\begin{code}
  type n = 256

  // Z is a Cryptol primitive such that Z q represents integers mod q that are 
  // closed under arithmetic operations
  type R = [n]Integer
  type R_q = [n](Z q)
\end{code}


\subheading{Modular reductions.}
For an even (resp.\ odd) positive integer~$\alpha$, 
we define $r'=r\modpm\, \alpha$ to be the unique element 
$r'$ in the range $-\frac{\alpha}{2}<r'\leq\frac{\alpha}{2}$ 
(resp. $-\frac{\alpha-1}{2}\leq r'\leq \frac{\alpha-1}{2}$) such that $r'=r\bmod \alpha$. 
For any positive integer $\alpha$, 
we define $r'=r\modp \alpha$ to be the unique element $r'$ 
in the range $0\leq r'<\alpha$ such that $r'=r\bmod \alpha$. 
When the exact representation is not important, we simply write $r\bmod \alpha$.  

\begin{code}
  modpm : {alpha} (fin alpha, alpha > 0) => Z alpha -> Integer
  modpm r = if r' > (`alpha / 2) then r' - `alpha else r'
    where r' = fromZ(r)
\end{code}

\subheading{Rounding.}
For an element $x \in \mathbb{Q}$ we denote by $\lceil x \rfloor$ 
rounding of $x$ to the closest integer with ties being rounded up.

\begin{code}
  // In Cryptol, rounding is computed via the built-in function roundToEven
  property rounding = ((roundToEven(1.5) == 2) && (roundToEven(1.4) == 1))
\end{code}

\subheading{Sizes of elements.}
For an element $w\in\Z_q$, we write $\|w\|_\infty$ to mean $|w\modpm\, q|$.  
We now define the $\ell_\infty$ and $\ell_2$ norms for 
$w=w_0+w_1X+\ldots +w_{n-1}X^{n-1}\in R$: 
$$\|w\|_\infty=\max_{i}{\|w_i\|_\infty},\,\,\,\, \|w\|=\sqrt{\|w_0\|_\infty^2+\ldots+\|w_{n-1}\|_\infty^2}.$$   
Similarly, for $\wpo=(w_1,\ldots,w_k)\in R^k$, we define 
$$\|\wpo\|_\infty=\max_{i}{\|w_i\|_\infty},\,\,\,\, \|\wpo\|=\sqrt{\|w_1\|^2+\ldots+\|w_k\|^2}.$$

\subheading{Sets and Distributions.}
For a set $S$, we write $s\gets S$ to denote that $s$ is chosen uniformly at random from $S$.  
If $S$ is a probability distribution, then this denotes that $s$ is chosen according to the distribution $S$.  

\begin{code}
  // Cryptol does not support sampling. Therefore, for every algorithm, we denote
  // its randomness as an explicit input value.
\end{code}

\subheading{Compression and Decompression.}
We now define a function $\KyberCompress(x,d)$ that takes an element $x\in\Z_q$ and outputs an integer in $\{0,\dots,2^d-1\}$,
where $d<\lceil \log_2(q) \rceil$. We furthermore define a function \KyberDecompress, such that
\begin{equation}\label{eq:xprime}
x' = \KyberDecompress\big(\KyberCompress(x,d),d\big)
\end{equation}
is an element close to $x$ -- more specifically
\begin{equation}\label{eq:Bq} 
|x'-x\modpm\, q|\leq B_q\coloneqq \left\lceil \frac{q}{2^{d+1}}\right\rfloor\,.
\end{equation}
The functions satisfying these requirements are defined as:
\begin{align*}
  \KyberCompress(x,d)   &= \lceil (2^d/q)\cdot x \rfloor \modp 2^d\,,\\
  \KyberDecompress(x,d) &= \lceil (q/2^d)\cdot x \rfloor\,.
\end{align*}

\begin{code}
  Compress'' : {d} (d < lg2 q) => Z q -> [d]
  Compress'' x = fromInteger(roundToEven(((2^^`d)/.`q) * fromInteger(fromZ(x))) % 2^^`d)

  Decompress'' : {d} (d < lg2 q) => [d] -> Z q 
  Decompress'' x = fromInteger(roundToEven(((`q)/.(2^^`d))*fromInteger(toInteger(x))))

  DecompressM'' : {d} (d < lg2 q) => [d] -> Z q 
  DecompressM'' x = fromInteger(roundToEven(((`q+1)/.(2^^`d))*fromInteger(toInteger(x))))


  B_q : {d} (d < lg2 q) => Integer
  B_q = roundToEven((`q/.(2^^(`d+1))))

  CorrectnessCompress : Z q -> Bit
  property CorrectnessCompress x = err <= B_q`{d_u} where
    x' = Decompress''`{d_u}(Compress''`{d_u}(x))
    err = abs(modpm(x'-x))
\end{code}

When \KyberCompress or \KyberDecompress is used with $x \in R_q$ or $\xpo \in R_q^k$, 
the procedure is applied to each coefficient individually.

\begin{code}
  Compress' : {d} (d < lg2 q) => R_q -> [n][d]
  Compress' x = map Compress''`{d} x
  
  Decompress' : {d} (d < lg2 q) => [n][d] -> R_q
  Decompress' x = map Decompress''`{d} x
  
  DecompressM' : {d} (d < lg2 q) => [n][d] -> R_q
  DecompressM' x = map DecompressM''`{d} x

  Compress : {d, k1} (d < lg2 q, fin k1) => [k1]R_q -> [k1][n][d]
  Compress x = map Compress'`{d} x
  
  Decompress : {d, k1} (d < lg2 q, fin k1) => [k1][n][d] -> [k1]R_q
  Decompress x = map Decompress'`{d} x

  DecompressM : {d, k1} (d < lg2 q, fin k1) => [k1][n][d] -> [k1]R_q
  DecompressM x = map Decompress'`{d} x
\end{code}

The main reason for defining the \KyberCompress and \KyberDecompress 
functions is to be able to discard some low-order bits in the ciphertext 
which do not have much effect on the correctness probability of decryption -- thus reducing the
size of ciphertexts.

The \KyberCompress and \KyberDecompress are also used for a purpose other than compression -- namely to perform the usual LWE error correction during encryption and decryption. 
More precisely, in line~\ref{line:kybercpa-enc:v} of the encryption procedure 
(Algorithm~\ref{kybercpa-enc}) 
the \KyberDecompress function is used to create error tolerance gaps 
by sending the message bit $0$ to $0$ and $1$ to $\lceil q/2\rfloor$. 
Later, on line~\ref{line:decrypt} of the decryption procedure (Algorithm~\ref{kybercpa-dec}), 
the \KyberCompress function is used to decrypt to a $1$ if $v-\spo^T\upo$ is closer to $\lceil q/2\rfloor$ than to $0$, 
and decrypt to a $0$ otherwise.


\subheading{Symmetric primitives.}
The design of \Kyber makes use of 
a pseudorandom function $\PRF\colon\Bytes^{32}\times \Bytes \rightarrow \Bytes^*$
and of an extendable output function $\XOF\colon\Bytes^*\times\Bytes\times\Bytes \rightarrow \Bytes^*$.
\Kyber also makes use of two hash functions $\ROH\colon\Bytes^* \rightarrow \Bytes^{32}$
and $\ROG\colon\Bytes^* \rightarrow \Bytes^{32}\times\Bytes^{32}$ and of
a key-derivation function $\KDF\colon\Bytes^* \rightarrow \Bytes^*$.

\begin{code}
  // These types distinguish infinite from finite length
  PRF : {prfeta} (fin prfeta, prfeta > 0) => ([32]Byte, Byte) -> [64 * prfeta]Byte
  XOF : ([32]Byte, Byte, Byte) -> [inf]Byte
  H : {hinl} (fin hinl) => [hinl]Byte -> [32]Byte
  G : {ginl} (fin ginl) => [ginl]Byte -> ([32]Byte, [32]Byte)
  KDF : {kdfinl} (fin kdfinl, kdfinl > 0) => [kdfinl]Byte -> [inf]Byte
\end{code}

\subheading{NTTs, multiplication, and bitreversed order.}
A very efficient way to perform multiplications in $R_q$ is via
the so-called \emph{number-theoretic transform} (NTT).

For our prime $q = 3329$ with $q - 1 = 2^8\cdot 13$, the base field $\Z_q$ contains primitive $256$-th roots of unity but not primitive $512$-th roots. Therefore, the defining polynomial $X^{256} + 1$ of $R$ factors into $128$ polynomials of degree $2$ modulo $q$ and the NTT of a polynomial $f \in R_q$ is a vector of $128$ polynomials of degree one. Simple in-place implementations of the NTT without reordering outputs these polynomials in bit-reversed order and we define the NTT in this way. Concretely, let $\zeta = 17$ be the first primitive $256$-th root of unity modulo $q$, and $\{\zeta,\zeta^3,\zeta^5,\ldots,\zeta^{255}\}$ the set of all the $256$-th roots of unity.  The polynomial $X^{256}+1$ can therefore be written as 
$$X^{256}+1 = \prod\limits_{i=0}^{127} (X^2-\zeta^{2i+1}) = \prod\limits_{i=0}^{127} (X^2-\zeta^{2\brev_7(i)+1}),$$ where $\brev_7(i)$ for $i = 0, \dots, 127$ is the bit reversal of the unsigned $7$-bit integer $i$. This latter ordering of the factors is useful for compatibility with the idiosyncrasies of AVX instructions.  Then the NTT of $f \in R_q$ is given by 
\begin{equation}\label{eq:NTTdef}
(f \bmod X^2 - \zeta^{2\brev_7(0) + 1}, \dots, f \bmod X^2 - \zeta^{2\brev_7(127) + 1}).
\end{equation}

\begin{code}
  zeta = 17 : Z q

  QMinusOne : Bit
  property QMinusOne = `q - 1 == 2^^8*13

  Is256thRootOfq : [lg2 q] -> Bit
  property Is256thRootOfq p = (p == 0) || (p >= 256) || (zeta^^p != 1)

  br7 : [8] -> [8]
  br7 = reverse
\end{code}

 This vector of linear polynomials is then serialized to a vector in $\Z_q^{256}$ in the canonical way. Moreover, in order to not introduce additional data types and facilitate in-place implementations of the NTT we define $\NTT \colon R_q \to R_q$ to be the bijection that maps $f \in R_q$ to the polynomial with the aforementioned coefficient vector. Hence,
%
\begin{align}
  \NTT(f) &= \hat{f} = \hat{f}_0 + \hat{f}_1 X + \dots + \hat{f}_{255}X^{255} \nonumber \\
\intertext{with}
  \hat{f}_{2i} &= \sum_{j = 0}^{127} f_{2j}\zeta^{\left(2\brev_7(i) + 1\right)j},\label{eq:coeffeven} \\
  \hat{f}_{2i + 1} &= \sum_{j = 0}^{127} f_{2j + 1}\zeta^{\left(2\brev_7(i) + 1\right)j}.\label{eq:coeffodd}
\end{align} 

\begin{code}
  ParametricNTT : R_q -> (Z q) -> R_q
  ParametricNTT f root = join[[f2i i, f2iPlus1 i] | i <- [0 .. 127]]
    where f2i i      = sum [f@(2*j)   * root ^^ ((2*(br7 i >> 1)+1)*j) | j <- [0 .. 127]]
          f2iPlus1 i = sum [f@(2*j+1) * root ^^ ((2*(br7 i >> 1)+1)*j) | j <- [0 .. 127]]

  ParametricNTTInv : R_q -> (Z q) -> R_q
  ParametricNTTInv f root = join[[f2i i, f2iPlus1 i] | i <- [0 .. 127]]
    where f2i i      = sum [f@(2*j)   * root ^^ ((2*(br7 j >> 1)+1)*i) | j <- [0 .. 127]]
          f2iPlus1 i = sum [f@(2*j+1) * root ^^ ((2*(br7 j >> 1)+1)*i) | j <- [0 .. 127]]

  NTT' : R_q -> R_q
  NTT' f = ParametricNTT f zeta
  
  NTTInv' : R_q -> R_q
  NTTInv' f = [term*(recip 128) | term <- ParametricNTTInv f (recip zeta)]
  
  CorrectnessNTT : R_q -> Bit
  property CorrectnessNTT f =  NTTInv' (NTT' f) == f
\end{code}

We would like to stress that even though we write $\hat{f}$ as a polynomial in $R_q$, it has no algebraic meaning as such.  The natural algebraic representation of $\NTT(f) = \hat{f}$ is as $128$ polynomials of degree $1$ as in \eqref{eq:NTTdef} using the definitions for $\hat{f}_i$ from \eqref{eq:coeffeven} and \eqref{eq:coeffodd}.  That is, 
$$\NTT(f) = \hat{f} = (\hat{f}_0+\hat{f}_1X,\hat{f}_2+\hat{f}_3X,\ldots,\hat{f}_{254}+\hat{f}_{255}X).$$

Using \NTT and its inverse \INVNTT we can compute the product $f\cdot g$ of
two elements $f,g \in R_q$ very efficiently as $\INVNTT(\NTT(f)\pw\NTT(g))$ where $\NTT(f) \pw \NTT(g) = \hat{f} \pw \hat{g} = \hat{h}$ denotes the basecase multiplication consisting of the $128$ products
%
\begin{equation*}
  \hat{h}_{2i} + \hat{h}_{2i + 1}X = (\hat{f}_{2i} + \hat{f}_{2i + 1}X)(\hat{g}_{2i} + \hat{g}_{2i + 1}X) \bmod X^2 - \zeta^{2\brev_7(i) + 1}
\end{equation*}
%
of linear polynomials.

\begin{code}
  base_mul : [2] (Z q) -> [2] (Z q) -> (Z q) -> [2] (Z q)
  base_mul a b root = [r0, r1]
    where
      r0 = a@1 * b@1 * root + a@0 * b@0
      r1 = a@0 * b@1 + a@1 * b@0
  
  point2mul : R_q -> R_q -> R_q
  point2mul a b = join [base_mul (poly1 i) (poly2 i) (root i) | i : Byte <- [0 .. 127]]
    where
      poly1 i = [a@(2*i),a@(2*i+1)]
      poly2 i = [b@(2*i),b@(2*i+1)]
      root i = (zeta^^(reverse (64 + (i >> 1)) >> 1) * ((-1 : (Z q)) ^^ (i)))

  prod : R_q -> R_q -> R_q
  prod f g = NTTInv' (point2mul (NTT' f) (NTT' g))

  // Testing that (1+x)^2 = 1+2x+x^2
  TestMult : Bit
  property TestMult = prod f f == fsq where
    f = [1, 1] # [0 | i <- [3 .. 256]]
    fsq = [1,2,1] # [0 | i <- [4 .. 256]]
  
  dot : R_q -> R_q -> R_q
  dot f g = point2mul f  g
  
  add : R_q -> R_q -> R_q
  add f g = f + g
\end{code}

When we apply \NTT or \INVNTT to a vector or matrix of elements of $R_q$,
then this means that the respective operation is applied to each entry
individually.

\begin{code}
  NTT v = map NTT' v
  NTTInv v = map NTTInv' v
\end{code}

When we apply $\pw$ to matrices or vectors it means that 
we perform a usual matrix multiplication, but that the individual products
of entries are the above basecase multiplications.

\begin{code}
  dotVecVec : {k1} (fin k1) => [k1]R_q -> [k1]R_q -> R_q
  dotVecVec v1 v2 = foldl add zero (zipWith dot v1 v2)
  
  dotMatVec : {k1,k2} (fin k1, fin k2) => [k1][k2]R_q -> [k2]R_q -> [k1]R_q
  dotMatVec matrix vector = [dotVecVec v1 vector | v1 <- matrix]
  
  dotMatMat :{k1,k2,k3} (fin k1, fin k2, fin k3) =>
    [k1][k2]R_q -> [k2][k3]R_q -> [k1][k3]R_q
  dotMatMat matrix1 matrix2 = transpose [dotMatVec matrix1 vector | vector <- m']
      where m' = transpose matrix2
\end{code}

Throughout the document we will write \NTT and \INVNTT whenever we refer
to the concrete functions as defined above and use normal-font NTT
whenever we refer to the general technique.

\subheading{Uniform sampling in $R_q$.}
\Kyber uses a deterministic approach to sample elements in $R_q$
that are statistically close to a uniformly random distribution.
For this sampling we use a function $\Parse\colon\Bytes^* \rightarrow R_q$, 
which receives as input a byte stream $B = b_0, b_1, b_2, \dots$ and
computes the NTT-representation $\hat{a} = \hat{a}_0 + \hat{a}_1 X + \dots + \hat{a}_{n-1}X^{n-1} \in R_q$ of $a \in R_q$. $\Parse$ is described in Algorithm~\ref{alg:parse} (note that this description assumes that $q=3329$).

\begin{algorithm}
  \caption{$\Parse\colon\Bytes^* \rightarrow R_q^n$}
  \label{alg:parse}
\begin{algorithmic}
  \Require Byte stream $B = b_0, b_1, b_2 \dots \in \Bytes^*$ 
  \Ensure NTT-representation $\hat{a} \in R_q$ of $a \in R_q$
  \State $i \coloneqq 0$
  \State $j \coloneqq 0$
  \While{$j < n$}
    \State $d_1 \coloneqq b_i + 256\cdot (b_{i+1}\modp 16)$
    \State $d_2 \coloneqq \lfloor b_{i+1}/16\rfloor + 16\cdot b_{i+2}$
    \If{$d_1 < q$}
      \State $\hat{a}_j \coloneqq d_1$\label{line:parse:bitrev1}
      \State $j \coloneqq j+1$
    \EndIf
    \If{$d_2 < q$ \textbf{and} $j < n$}
      \State $\hat{a}_j \coloneqq d_2$\label{line:parse:bitrev2}
      \State $j \coloneqq j+1$
    \EndIf
    \State $i \coloneqq i+3$
  \EndWhile
  \State \Return $\hat{a}_0 + \hat{a}_1 X + \dots + \hat{a}_{n-1}X^{n-1}$
\end{algorithmic}
\end{algorithm}

\begin{code}
  // Since Cryptol does not natively support while loops, we approach this
  // potentially infinite loop with recursion. We define ParseInf that 
  // converts an infinite sequence of bytes to an infinite sequence of
  // elements in Z q. We then pick the first n elements for the result.

  Parse : [inf]Byte -> R_q // Spec has a typo
  Parse b = take`{n} elements
      where elements = ParseInf b

  // ParseInf implements a filter. It scans the input 3 by 3, calculates
  // the elements d1 and d2 and finally returns the elements that satisfy 
  // the conditions together with the result of itself when applied to the
  // tail.

  ParseInf: [inf]Byte -> [inf](Z q)
  ParseInf ([bi,bi1,bi2] # tailS) =
      if d1 < `q then
          if d2 < `q then
              [fromInteger(d1),fromInteger(d2)] # ParseInf tailS
          else
              [fromInteger(d1)] # ParseInf tailS
      else
          if d2 < `q then
              [fromInteger(d2)] # ParseInf tailS
          else
              ParseInf tailS
      where
          d1 = toInteger(reverse bi) + 256 * (toInteger(reverse bi1) % 16)
          d2 = floor(ratio (toInteger(reverse bi1)) 16) + 16 * toInteger(reverse bi2)
\end{code}

The intuition behind the function \Parse is that if the input byte array
is statistically close to a uniformly random byte array, then the output
polynomial is statistically close to a uniformly random element of $R_q$. 
It represents a uniformly random polynomial in $R_q$ because $\NTT$ is bijective and thus maps polynomials with uniformly random coefficients to polynomials with again uniformly random coefficients. 

%Note that in line~\ref{line:parse:bitrev} we bitreverse the index;
%this ensures that when \Parse writes output as a consecutive stream,
%the output is in NTT domain with bitreversed coefficient order; i.e.,
%in precisely the format that typical implementations of \INVNTT take as input.

\subheading{Sampling from a binomial distribution.}
Noise in \Kyber is sampled from a centered binomial distribution $B_{\eta}$
for $\eta=2$ or $\eta=3$. We define $B_\eta$ as follows:
\[
\text{Sample } (a_1,\ldots,a_\eta,b_1,\ldots,b_\eta)\gets \{0,1\}^{2\eta}\]
\[\text{ and output }\sum_{i=1}^\eta (a_i-b_i).\]
When we write that a polynomial $f \in R_q$ or a vector of such polynomials
is sampled from $B_\eta$, we mean that each coefficient is sampled from $B_\eta$.

For the specification of \Kyber we need to define how a polynomial $f \in R_q$ 
is sampled according to $B_\eta$ deterministically from $64\eta$ bytes of output of a
pseudorandom function (we fix $n=256$ in this description). 
This is done by the function \CBD (for ``centered binomial distribution'')
defined as described in Algorithm~\ref{alg:cbd}.

\begin{algorithm}
  \caption{$\CBD_{\eta}\colon\Bytes^{64\eta} \rightarrow R_q$
  }
  \label{alg:cbd}
  \begin{algorithmic}
    \Require Byte array $B = (b_0, b_1, \dots ,b_{64\eta-1}) \in \Bytes^{64\eta}$ 
    \Ensure Polynomial $f \in R_q$
    \State $(\beta_0,\dots,\beta_{512\eta-1}) \coloneqq \mathsf{BytesToBits}(B)$
    \For{$i$ from $0$ to $255$}
      \State $a \coloneqq \sum_{j=0}^{\eta-1}\beta_{2i\eta+j}$
      \State $b \coloneqq \sum_{j=0}^{\eta-1}\beta_{2i\eta+\eta+j}$
      \State $f_i \coloneqq a-b$
    \EndFor
    \State \Return $f_0 + f_1X + f_2X^2 + \dots + f_{255}X^{255}$
  \end{algorithmic}
\end{algorithm}

\begin{code}
  CBD: {eta} (fin eta, eta > 0) => [64 * eta]Byte -> R_q
  CBD B = [f i | i <- [0 .. 255]]
      where betas = BytesToBits B : [512 * eta]
            a i = sum [BitToZ`{q} (betas@(2*i*`eta+j)) | j <- [0 .. (eta-1)]]
            b i = sum [BitToZ`{q} (betas@(2*i*`eta+`eta+j)) | j <- [0 .. (eta-1)]]
            f i = (a i) - (b i)
\end{code}

\subheading{Encoding and decoding.}
There are two data types that \Kyber needs to serialize to byte arrays:
byte arrays and (vectors of) polynomials. Byte arrays are trivially serialized
via the identity, so we need to define how we serialize and deserialize polynomials.

\begin{code}
  // We make this trivial serialization explicit, since it is not an identity in Cryptol

  EncodeBytes' : {ell} (fin ell, ell > 0) => [n][ell] -> [32 * ell]Byte
  EncodeBytes' B = groupBy(join (reverse B))

  DecodeBytes' : {ell} (fin ell, ell > 0) => [32 * ell]Byte -> [n][ell]
  DecodeBytes' B = groupBy(join (reverse B))
  
  CorrectnessEncodeBytes' : [n][2] -> Bit
  property CorrectnessEncodeBytes' B = DecodeBytes'(EncodeBytes' B) == B
  
  EncodeBytes : {ell, k1} (fin ell, ell > 0, fin k1) =>
      [k1][n][ell] -> [32 * ell * k1]Byte
  EncodeBytes B = groupBy(join (reverse (join (reverse B))))
  
  DecodeBytes : {ell, k1} (fin ell, ell > 0, fin k1) =>
      [32 * ell * k1]Byte -> [k1][n][ell]
  DecodeBytes B = groupBy(reverse (groupBy(join (reverse B))))
  
  CorrectnessEncodeBytes : [k][n][2] -> Bit
  property CorrectnessEncodeBytes B = DecodeBytes(EncodeBytes B) == B
\end{code}

In Algorithm~\ref{alg:decode} we give a pseudocode description of the
function $\Decode_\ell$, which deserializes an array of $32\ell$ bytes
into a polynomial $f = f_0 + f_1X + \dots + f_{255}X^{255}$ 
(we again fix $n=256$ in this description) with each
coefficient $f_i$ in  $\{0,\dots,2^\ell-1\}$. 
We define the function $\Encode_\ell$ as the inverse of $\Decode_\ell$.
Whenever we apply $\Encode_\ell$ to a vector of polynomials we encode
each polynomial individually and concatenate the output byte arrays.

\begin{code}
  Encode : {ell, k1} (fin ell, ell > 0, fin k1) => [k1]R_q -> [32 * ell * k1]Byte
  Encode fVec = join [(Encode'`{ell} f) | f <- fVec]
  
  Decode : {ell, k1} (fin ell, ell > 0, fin k1) => [32 * ell * k1]Byte -> [k1]R_q
  Decode BVec = [(Decode'`{ell} B) | B <- split BVec]
  
  CorrectnessEncodeDecode : [k]R_q -> Bit
  property CorrectnessEncodeDecode fVec = all CorrectnessEncodeDecode' fVec
\end{code}

\begin{algorithm}
  \caption{$\Decode_\ell\colon\Bytes^{32\ell}\rightarrow R_q$
  }
  \label{alg:decode}
  \begin{algorithmic}
    \Require Byte array $B \in \Bytes^{32\ell}$ 
    \Ensure Polynomial $f \in R_q$
    \State $(\beta_0,\dots,\beta_{256\ell-1}) \coloneqq \mathsf{BytesToBits}(B)$
    \For{$i$ from $0$ to $255$}
      \State $f_i \coloneqq \sum_{j=0}^{\ell-1}\beta_{i\ell+j}2^{j}$
    \EndFor
    \State \Return $f_0 + f_1X + f_2X^2 + \dots + f_{255}X^{255}$
  \end{algorithmic}
\end{algorithm}

\begin{code}
  Decode' : {ell} (fin ell, ell > 0) => [32 * ell]Byte -> R_q
  Decode' B = [f i | i <- [0 .. 255]]
      where betas = BytesToBits B : [256 * ell]
            f i = sum [ BitToZ`{q}(betas@(i*`ell+j))*fromInteger(2^^j)
                      | j <- [0 .. (ell-1)]]
  
  Encode' : {ell} (fin ell, ell > 0) => R_q -> [32 * ell]Byte
  Encode' f = groupBy`{8} (join [reverse (fromInteger((fromZ(fi)))) | fi <- f : R_q])
  
  CorrectnessEncodeDecode' : R_q -> Bit
  property CorrectnessEncodeDecode' f = Decode'`{12}(Encode'`{12} f) == f
\end{code}

\subsection{Specification of \KyberCPAPKE}
\label{subsec:specification:cpaenc}

\KyberCPAPKE is similar to the LPR encryption scheme that was introduced
(for Ring-LWE) by Lyubashevsky, Peikert, and Regev in the presentation
of~\cite{LPR10} at Eurocrypt 2010~\cite{Eurocrypt2010PeikertSlides};
the description is also in the full version of the paper~\cite[Sec.~1.1]{lyubashevsky2013RLWE}.
The roots of this scheme go back to the first LWE-based encryption scheme
presented by Regev in~\cite{regev2005lattices,regev2009lwe}, with the main difference being that the underlying ring is not $\Z_q$ and both the secret and the error vectors have small coefficients.  The idea of using a polynomial ring (instead of $\Z_q$) goes back to the NTRU cryptosystem
presented by Hoffstein, Pipher, and Silverman in~\cite{hoffstein1998ntru}, while the symmetry between the secret and the error was already employed in very similar cryptographic schemes in \cite{DBLP:conf/focs/Alekhnovich03,DBLP:conf/tcc/LyubashevskyPS10} with the security justification from \cite{DBLP:conf/crypto/ApplebaumCPS09}. 

The main difference from the LPR encryption scheme 
is to use Module-LWE instead of Ring-LWE. 
Also, we adopt the approach taken by Alk{\i}m, Ducas, PÃ¶ppelmann and Schwabe in~\cite{ADPS16}
for the generation of the public matrix $\Apo$.
Furthermore, we shorten ciphertexts by rounding off
the low bits as in learning-with-rounding-based schemes~\cite[Eq.~2.1]{banerjee2012pseudorandom}, 
which is a common technique for reducing ciphertext size also in LWE-based schemes (c.f. \cite{Pei09b,Poppelmann2013hwrlwe}).

\subheading{Parameters.}
\KyberCPAPKE is parameterized by integers $n$, $k$, $q$, $\eta_1$, $\eta_2$, $d_u$, and $d_v$.
As stated before, throughout this document $n$ is always $256$ and $q$ is always $3329$.
%Furthermore, throughout this document $\eta$ is always $2$.
%The values of $k$, $d_u$ and $d_v$ vary for different security levels.

Using the notation of Subsection~\ref{subsec:specification:prelim} we give the definition of key generation, encryption, and decryption
of the \KyberCPAPKE public-key encryption scheme in Algorithms~\ref{kybercpa-gen},~\ref{kybercpa-enc}, and~\ref{kybercpa-dec}.
A more high-level view of these algorithms is given in the comments.

\begin{algorithm}
  \caption{$\KyberCPAPKE.\PKEGen()$: key generation
  \label{kybercpa-gen}}
  \begin{algorithmic}[1]
    \Ensure Secret key $\sk \in \Bytes^{12\cdot k\cdot n/8}$
    \Ensure Public key $\pk \in \Bytes^{12\cdot k\cdot n/8 + 32}$
    \State $d \gets \Bytes^{32}$                  \label{line:secretrandomness}
    \State $(\rho, \sigma) \coloneqq \ROG(d)$ 
    \State $N \coloneqq 0$
    \For{$i$ from $0$ to $k-1$}           \Comment{Generate matrix $\hat{\Apo} \in R_q^{k\times k}$ in \NTT domain}
    \For{$j$ from $0$ to $k-1$}
      \State $\hat{\Apo}[i][j] \coloneqq \Parse(\XOF(\rho, j, i))$
    \EndFor
    \EndFor
    \For{$i$ from $0$ to $k-1$}           \Comment{Sample $\spo \in R_q^k$ from $B_{\eta_1}$}
    \State $\spo[i] \coloneqq \CBD_{\eta_1}(\PRF(\sigma, N))$
    \State $N \coloneqq N+1$
    \EndFor
    \For{$i$ from $0$ to $k-1$}           \Comment{Sample $\epo \in R_q^k$ from $B_{\eta_1}$}
    \State $\epo[i] \coloneqq \CBD_{\eta_1}(\PRF(\sigma, N))$
    \State $N \coloneqq N+1$
    \EndFor
    \State $\hat{\spo} \coloneqq \NTT(\spo)$\label{line:kybercpa-gen:ntts}
    \State $\hat{\epo} \coloneqq \NTT(\epo)$
    \State $\hat{\tpo} \coloneqq \hat{\Apo} \pw \hat{\spo} + \hat{\epo}$\label{line:kybercpa-gen:invnttas}
    \State $\pk \coloneqq (\Encode_{12}(\hat{\tpo} \modp q)\cat\rho)$\Comment{$\pk \coloneqq \Apo\spo + \epo$}
    \State $\sk \coloneqq \Encode_{12}(\hat{\spo} \modp q)$\Comment{$\sk \coloneqq \spo$}
    \State \Return $(\pk, \sk)$
  \end{algorithmic}
\end{algorithm}

\begin{code}
  KeyGen: ([32]Byte) -> ([12*k*n/8+32]Byte, [12*k*n/8]Byte)
  KeyGen(d) = (pk,sk) where
    (rho,sigma) = G(d)
    Ahat = [[Parse (XOF(rho,i,j)) | i <- [0 .. k-1]] | j <- [0 .. k-1]] : [k][k]R_q
    s = [CBD`{eta_1}(PRF`{eta_1}(sigma,N)) | N <- [0 .. k-1]] : [k]R_q
    e = [CBD`{eta_1}(PRF`{eta_1}(sigma,N)) | N <- [k .. (2*k-1)]] : [k]R_q
    shat = NTT(s)
    ehat = NTT(e)
    that = (dotMatVec Ahat shat) + ehat
    
    pk_rev = Encode`{12}(that)
    pk = [reverse (pk_rev@(i) : Byte) | i <- [0 .. 12*k*n/8-1]] # rho

    sk_rev = Encode`{12}(shat)
    sk = [reverse (sk_rev@(i) : Byte) | i <- [0 .. 12*k*n/8-1]]

\end{code}

\begin{algorithm}
  \caption{$\KyberCPAPKE.\PKEEnc(\pk, m, r)$: encryption
  \label{kybercpa-enc}}
  \begin{algorithmic}[1]
    \Require Public key $\pk \in \Bytes^{12\cdot k\cdot n/8 + 32}$
    \Require Message $m \in \Bytes^{32}$
    \Require Random coins $r \in \Bytes^{32}$
    \Ensure Ciphertext $c \in \Bytes^{d_u\cdot k\cdot n/8 + d_v\cdot n/8}$
    \State $N \coloneqq 0$
    \State $\hat{\tpo} \coloneqq \Decode_{12}(\pk)$
    \State $\rho \coloneqq \pk+12\cdot k\cdot n/8$
    \For{$i$ from $0$ to $k-1$}           \Comment{Generate matrix $\hat{\Apo} \in R_q^{k\times k}$ in \NTT domain}
    \For{$j$ from $0$ to $k-1$}
      \State $\hat{\Apo}^T[i][j] \coloneqq \Parse(\XOF(\rho, i, j))$     
    \EndFor
    \EndFor
    \For{$i$ from $0$ to $k-1$}\label{line:kybercpa-enc:rpo}       \Comment{Sample $\rpo \in R_q^k$ from $B_{\eta_1}$}
      \State $\rpo[i] \coloneqq \CBD_{\eta_1}(\PRF(r, N))$
      \State $N \coloneqq N+1$
    \EndFor
    \For{$i$ from $0$ to $k-1$}\label{line:kybercpa-enc:epo}       \Comment{Sample $\epo_1 \in R_q^k$ from $B_{\eta_2}$}
      \State $\epo_1[i] \coloneqq \CBD_{\eta_2}(\PRF(r, N))$
      \State $N \coloneqq N+1$
    \EndFor
    \State $e_2 \coloneqq \CBD_{\eta_2}(\PRF(r, N))$                 \Comment{Sample $e_2 \in R_q$ from $B_{\eta_2}$}
    \State $\hat{\rpo} \coloneqq \NTT(\rpo)$\label{line:kybercpa-enc:nttr}
    \State $\upo \coloneqq \INVNTT(\hat{\Apo}^T \pw \hat{\rpo}) + \epo_1$\label{line:kybercpa-enc:invnttar} \Comment{$\upo \coloneqq \Apo^T\rpo + \epo_1$}
    \State $v \coloneqq \INVNTT(\hat{\tpo}^T\pw\hat{\rpo}) + e_2 + \KyberDecompress(\Decode_1(m),1)$ \label{line:kybercpa-enc:v} \Comment{$v \coloneqq \tpo^T\rpo + e_2 + \KyberDecompress(m,1)$}
    \State $c_1 \coloneqq \Encode_{d_u}(\KyberCompress(\upo, d_u))$
    \State $c_2 \coloneqq \Encode_{d_v}(\KyberCompress(v, d_v))$
    \State \Return $c = (c_1\cat c_2)$ \Comment{$c \coloneqq (\KyberCompress(\upo,d_u),\KyberCompress(v,d_v)$)}
  \end{algorithmic}
\end{algorithm}

\begin{code}
  Enc : ([12*k*n/8+32]Byte, [32]Byte, [32]Byte) -> [d_u*k*n/8 + d_v*n/8]Byte
  Enc(pk, m, r) = c1#c2 where
    pk_rev = [reverse (pk@(i) : Byte) | i <- [0 .. 12*k*n/8-1]]
    that = Decode`{12} (take`{12*k*n/8} pk_rev) : [k]R_q
    rho = plus`{12*k*n/8} pk : [32]Byte
    Ahat = [[Parse (XOF(rho,i,j)) | i <- [0 .. k-1]] | j <- [0 .. k-1]] : [k][k]R_q
    rvec = [CBD`{eta_1}(PRF`{eta_1}(r,N)) | N <- [0 .. k-1]] : [k]R_q
    e1 = [CBD`{eta_2}(PRF`{eta_2}(r,N)) | N <- [k .. (2*k-1)]] : [k]R_q
    e2 = CBD`{eta_2}(PRF`{eta_2}(r,2*`k)) : R_q
    rvechat = NTT rvec
    u = NTTInv (dotMatVec (transpose Ahat) rvechat) + e1 : [k]R_q
    v = (NTTInv' (dotVecVec that rvechat)) + e2 + reverse(DecompressM'`{1}(DecodeBytes'`{1} m))

    c1_rev = EncodeBytes`{10}(Compress`{10}(u))
    c1 = join [reverse [c1_rev@(j+i*`d_u*`n/8) | j <- [0 .. d_u*n/8-1]] | i <- [0 .. k-1]] : [d_u*k*n/8]Byte
    
    c2_rev = EncodeBytes'`{d_v}(Compress'`{d_v}(v))
    c2 = reverse (c2_rev) : [d_v*n/8]Byte    
\end{code}

\begin{algorithm}
  \caption{$\KyberCPAPKE.\PKEDec(\sk,c)$: decryption\label{kybercpa-dec}}
  \begin{algorithmic}[1]
    \Require Secret key $\sk \in \Bytes^{12\cdot k\cdot n/8}$
    \Require Ciphertext $c \in \Bytes^{d_u\cdot k\cdot n/8 + d_v\cdot n/8}$
    \Ensure Message $m \in \Bytes^{32}$
    \State $\upo \coloneqq \KyberDecompress(\Decode_{d_u}(c),d_u)$
    \State $v \coloneqq \KyberDecompress(\Decode_{d_v}(c+d_u\cdot k\cdot n/8),d_v)$
    \State $\hat{\spo} \coloneqq \Decode_{12}(\sk)$
    \State $m \coloneqq \Encode_1(\KyberCompress(v-\INVNTT(\hat{\spo}^T\pw\NTT(\upo)),1))$ \label{line:decrypt} \Comment{$m \coloneqq \KyberCompress(v-\spo^T\upo,1))$}
    \State \Return $m$
\end{algorithmic}
\end{algorithm}

\begin{code}
  Dec : ([12*k*n/8]Byte, [d_u*k*n/8 + d_v*n/8]Byte) -> [32]Byte
  Dec(sk, c) = m where
    u = Decompress`{d_u}(DecodeBytes`{d_u}(take`{d_u*k*n/8}c))   : [k]R_q
    v = Decompress'`{d_v}(reverse(DecodeBytes'`{d_v}(plus`{d_u*k*n/8}c))) : R_q
    sk_rev = [reverse (sk@(i) : Byte) | i <- [0 .. 12*k*n/8-1]]
    shat = Decode`{12}(sk_rev) : [k]R_q

    m = reverse (EncodeBytes'`{1}(Compress'`{1}(v - NTTInv' (dotVecVec shat (NTT u)))))

  // Kyber is correct with probability 1-delta and not 1. As a result,
  // running :prove Correctness will not succeed since there is a 
  // fraction delta of seeds d,r that do not work. Therefore, we can 
  // only run :check Correctness. Cryptol does not currently support counting.

  CorrectnessPKE : ([32]Byte, [32]Byte, [32]Byte) -> Bit
  property CorrectnessPKE(d, m, r) = (m' == m) where
    (pk, sk) = KeyGen(d)
    c = Enc(pk, m, r)
    m' = Dec(sk, c)
\end{code}

\clearpage

\subsection{Specification of \KyberCCAKEM}
\label{subsec:specification:ccakem}

We construct the \KyberCCAKEM IND-CCA2-secure KEM from the IND-CPA-secure
public-key encryption scheme described in the previous subsection via a slightly
tweaked Fujisaki--Okamoto transform~\cite{C:FujOka99}. 
In Algorithms~\ref{alg:ccakeygen},~\ref{alg:ccaenc}, and~\ref{alg:ccadec}
we define key generation, encapsulation, and decapsulation of \KyberCCAKEM.

\begin{algorithm}
  \caption{$\KyberCCAKEM.\KEMGen()$
  \label{alg:ccakeygen}}
  \begin{algorithmic}[1]
    \Ensure Public key $\pk \in \Bytes^{12\cdot k\cdot n/8 + 32}$
    \Ensure Secret key $\sk \in \Bytes^{24\cdot k\cdot n/8 + 96}$
    \State $z \gets \Bytes^{32}$
    \State $(\pk,\sk') \coloneqq \KyberCPAPKE.\PKEGen()$
    \State $\sk \coloneqq (\sk'\cat \pk\cat \ROH(\pk)\cat z)$
    \State \Return $(\pk, \sk)$
  \end{algorithmic}
\end{algorithm}

\begin{code}
  // We make the randomness of KeyGen explicit
  CGen : ([32]Byte,[32]Byte) -> ([12*k*n/8+32]Byte,[24*k*n/8+96]Byte)
  CGen (z,d) = (pk,sk) where
    (pk,sk') = KeyGen(d)
    sk = sk'#pk#H(pk)#z
\end{code}

\begin{algorithm}
  \caption{$\KyberCCAKEM.\KEMEnc(\pk)$
  \label{alg:ccaenc}}
  \begin{algorithmic}[1]
    \Require Public key $\pk \in \Bytes^{12\cdot k\cdot n/8 + 32}$
    \Ensure Ciphertext $c \in \Bytes^{d_u\cdot k\cdot n/8 + d_v\cdot n/8}$
    \Ensure Shared key $K \in \Bytes^*$
    \State $m\gets \Bytes^{32}$\label{line:ccaenc:m}
    \State $m\gets \ROH(m)$\Comment{Do not send output of system RNG}
    \State $(\bar{K},r) \coloneqq \ROG(m\cat \ROH(\pk))$\label{line:ccaenc:r}
    \State $c \coloneqq \KyberCPAPKE.\PKEEnc(\pk, m, r)$
    \State $K \coloneqq \KDF(\bar{K}\cat \ROH(c))$\label{line:ccaenc:k}
    \State \Return $(c, K)$
  \end{algorithmic}
\end{algorithm}

\begin{code}
  // We make the random message m explicit
  CEnc : ([12*k*n/8+32]Byte, [32]Byte) -> ([d_u*k*n/8+d_v*n/8]Byte, [inf]Byte)
  CEnc (pk, m) = (c, map reverse K) where
    m' = H(m) // Cryptol warns about shadowing
    (KBar,r) = G(m'#H(pk))
    c = Enc(pk,m',r)
    K = KDF(KBar#H(c))
    // K_r = take`{32}(KDF(KBar#H(c)))
    // K = [reverse (K_r@(i)) | i <- [0 .. 31]]
\end{code}

\begin{algorithm}
  \caption{$\KyberCCAKEM.\KEMDec(c,\sk)$\label{alg:ccadec}}
  \begin{algorithmic}[1]
    \Require Ciphertext $c \in \Bytes^{d_u\cdot k\cdot n/8 + d_v\cdot n/8}$
    \Require Secret key $\sk \in \Bytes^{24\cdot k\cdot n/8 + 96}$
    \Ensure Shared key $K \in \Bytes^*$
    \State $\pk \coloneqq \sk+12\cdot k\cdot n/8$
    \State $h \coloneqq \sk+24\cdot k\cdot n/8 + 32 \in \Bytes^{32}$
    \State $z \coloneqq \sk+24\cdot k\cdot n/8 + 64$
    \State $m'\coloneqq \KyberCPAPKE.\PKEDec(\sk,c)$
    \State $(\bar{K}',r') \coloneqq \ROG(m'\cat h)$
    \State $c' \coloneqq \KyberCPAPKE.\PKEEnc(\pk, m', r')$
    \If{$c = c'$}
      \State \Return $K \coloneqq \KDF(\bar{K}'\cat \ROH(c))$
    \Else
      \State \Return $K \coloneqq \KDF(z\cat \ROH(c))$
    \EndIf 
    \State \Return $K$
  \end{algorithmic}
\end{algorithm}

\begin{code}
  CDec : ([d_u*k*n/8+d_v*n/8]Byte,[24*k*n/8+96]Byte) -> [inf]Byte
  CDec (c,sk) = map reverse K
    where
      sk' = sk@@[0 .. 12*k*n/8 - 1] //We make the first portion explicit
      pk = sk@@[12*k*n/8 .. 24*k*n/8+32 - 1]
      h = sk@@[24*k*n/8+32 .. 24*k*n/8+64-1] : [32]Byte
      z = plus`{24*k*n/8+64} sk
      m' = Dec(sk',c)
      (KBar', r') = G(m'#h)
      c' = Enc(pk,m',r')
      K = if (c == c') then KDF(KBar'#H(c))
                       else KDF(z#H(c))


  CorrectnessKEM : ([32]Byte, [32]Byte, [32]Byte) -> Bit
  property CorrectnessKEM(z, d, m) = ((take`{32}K) == (take`{32}K')) where
    (pk, sk) = CGen(z, d)
    (c, K) = CEnc(pk, m)
    K' = CDec(c, sk)
\end{code}

\subsection{\Kyber parameter sets}
\label{subsec:specification:params}

We define three parameter sets for \Kyber, which we call \KyberLow, \KyberMid, and \KyberHigh.
The parameters are listed in Table~\ref{tab:params}. Note that the table also lists the
derived parameter $\delta$, which is the probability that decapsulation of a valid
\KyberCCAKEM ciphertext fails. The parameters were obtained via the following approach:
\begin{itemize}
  \item $n$ is set to $256$ because the goal is to encapsulate keys with $256$ bits of entropy 
    (i.e., use a plaintext size of $256$ bits in \KyberCPAPKE.\PKEEnc).
    Smaller values of $n$ would require to encode multiple key bits into one polynomial
    coefficient, which requires lower noise levels and therefore lowers security.
    Larger values of $n$ would reduce the capability to easily scale security via
    parameter $k$.
  \item We choose $q$ as a small prime satisfying $n \mid (q-1)$; 
    this is required to enable the fast \NTT-based multiplication.
    There are two smaller primes for which this property holds, namely
    $257$ and $769$. However, for those primes we would not be able
    to achieve negligible failure probability required for CCA security, 
    so we chose the next largest, i.e., $q=3329$.
  \item $k$ is selected to fix the lattice dimension as a multiple of $n$;
    changing $k$ is the main mechanism in \Kyber to scale security (and as a consequence,
    efficiency) to different levels.
  \item The remaining parameters $\eta_1$, $\eta_2$, $d_u$ and $d_v$ were chosen to balance
    between security, ciphertext size,
    and failure probability. Note that all three parameter sets achieve a failure probability of $<2^{-128}$
    with some margin.
  \item The parameter $\eta_1$ defines the noise of $\spo$ and $\epo$ in Algorithm~\ref{kybercpa-gen} and of $\rpo$ in Algorithm~\ref{kybercpa-enc}.  The parameter $\eta_2$ defines the noise of $\epo_1$ and $e_2$ in Algorithm~\ref{kybercpa-enc}. 
\end{itemize}

The failure probability $\delta$ is computed with the help of the \verb_Kyber.py_ 
Python script which is available online at 
\url{https://github.com/pq-crystals/security-estimates}.
For the theoretical background of that script see~\cite[Theorem~1]{BDK+18}.

\begin{table*}
  \caption{Parameter sets for \Kyber}
  \label{tab:params}
\begin{tabularx}{\textwidth}{Xccccccc}
\toprule
           & $n$   & {$k$} & {$q$}  & {$\eta_1$} & {$\eta_2$} & {$(d_u,d_v)$} & {$\delta$} \\
\midrule
\KyberLow  & $256$ & $2$   & $3329$ & $3$ & $2$      & $(10,4)$      & $2^{-139}$ \\
\KyberMid  & $256$ & $3$   & $3329$ & $2$  & $2$     & $(10,4)$      & $2^{-164}$ \\
\KyberHigh & $256$ & $4$   & $3329$ & $2$   & $2$    & $(11,5)$      & $2^{-174}$ \\
\bottomrule
\end{tabularx}
\end{table*}

\begin{code}
  parameter
    type q : #
    type constraint (prime q, fin q, lg2 q > 10)
    type k : #
    type constraint (width k > 0, width 2*k <= 8)
    type eta_1 : #
    type constraint (fin eta_1, eta_1 > 0)
    type eta_2 : #
    type constraint (fin eta_2, eta_2 > 0)
    type d_u : #
    type constraint (fin d_u, d_u < lg2 q, d_u > 0)
    type d_v : #
    type constraint (fin d_v, d_v < lg2 q, d_v > 0)
\end{code}

\subheading{Instantiating \PRF, \XOF, \ROH, \ROG, and \KDF.}
What is still missing to complete the specification of \Kyber is
the instantiation of the symmetric primitives. We instantiate
all of those primitives with functions from the FIPS-202 standard~\cite{fips202}
as follows:
\begin{itemize}
  \item We instantiate \XOF with SHAKE-128;
  \item we instantiate \ROH with SHA3-256;
  \item we instantiate \ROG with SHA3-512;
  \item we instantiate $\PRF(s,b)$ with SHAKE-256$(s || b)$; and
  \item we instantiate \KDF with SHAKE-256.
\end{itemize}

\begin{code}
  import Primitive::Keyless::Hash::utils
  import Primitive::Keyless::Hash::SHAKE::SHAKE128
  XOF(rho, i, j) = groupBy`{8}(shake128((fromBytes(rho))# reverse i# reverse j))
  
  import `Primitive::Keyless::Hash::SHA3::SHA3
  H M = toBytes(sha3 `{digest = 256} (fromBytes(M)))
  
  G M = (result@0, result@1)
      where result = split`{2} (toBytes(sha3 `{digest = 512} (fromBytes(M))))
  
  import Primitive::Keyless::Hash::SHAKE::SHAKE256
  PRF(s,b) = (groupBy`{8}(shake256(fromBytes(s)# reverse b)))@@[0 .. (64*prfeta-1)]
  
  KDF input = groupBy`{8}(shake256 (fromBytes(input)))
\end{code}

\subheading{``90s'' variant of \Kyber.}
In the 90s variant of \Kyber
\begin{itemize}
  \item we instantiate $\XOF(\rho,i,j)$ with AES-256 in CTR mode, where $\rho$ is used as the key and $i\cat j$ is zero-padded to a $12$-byte nonce.
    The counter of CTR mode is initialized to zero.
  \item we instantiate \ROH with SHA-256;
  \item we instantiate \ROG with SHA-512;
  \item we instantiate $\PRF(s,b)$ with AES-256 in CTR mode, where $s$ is used as the key and $b$ is zero-padded to a $12$-byte nonce.
    The counter of CTR mode is initialized to zero.
  \item we instantiate \KDF with SHA-256.
\end{itemize}
