/**
 * This module implements a subset of the RSA encryption, decryption, signature,
 * and signature verification primitives per their definitions in RFC 8017 (PKCS #1).
 * These primitives are all modular exponentiations over a specially constructed modulus.
 *
 * The security of the RSA cryptographic primitives are subtle. A user of this module
 * should note that conformance to RFC 8017 does not imply conformance to NIST or FIPS
 * standards concerning integer factorization cryptography. We will reference these
 * other standards when possible to illuminate the points of difference between them.
 * We will also note future intent to implement the RSA primitives tailored to these
 * standards in other modules.
 *
 * This module is less general than RFC 8017. The author's have made the pragmatic
 * decision to encode as many constraints specified by RFC 8017 in Cryptol's type system
 * as possible. As a result, we allow RSA moduli with only two prime factors; the RFC
 * allows any number of factors greater than or equal to two. The authors of this specification
 * have made this decision based on the fact that NIST and FIPS standards allow only "bi-prime"
 * RSA. Thus, the authors thought it a pragmatic middle ground between conformance to the RFC
 * and ease of clear expression in Cryptol.
 *
 * Users of this module should further note that some of the type signatures of the functions
 * in this module do not exactly correspond to the type signatures specified in the RFC. When
 * such a situation arises, an explanation will be provided in the doc comment above the function.
 *
 * References:
 *    [RFC 8017]
 *    Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 2.1
 *    J. Jonson, B. Kaliski, RSA Laboratories; February 2003.
 *    @see https://datatracker.ietf.org/doc/html/rfc8017#page-70
 *
 *    [FIPS 186-5]
 *    Digital Signature Standard (DSS)
 *    Information Technology Laboratory, National Institute of Standards and Technology.
 *    February 3, 2023.
 *    @see https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-5.pdf
 *
 *    [SP 800-56B]
 *    Recommendation for Pair-Wise Key-Establishment Using Integer Factorization Cryptography (Rev 2)
 *    E. Barker, L. Chen, A. Roginski, A. Vassilev, R. Davis, S. Simon.
 *    National Institute of Standards and Technology
 *    March 2019.
 *    @see https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-56Br2.pdf
 *
 *    [SP 800-175B]
 *    Guideline for Using Cryptographic Standards in the Federal Government
 *    E. Barker
 *    National Institute of Standards and Technology
 *    March 2020
 *    @see https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-175Br1.pdf
 *
 *
 *
 * @author John Christensen <jchristensen@galois.com>
 * @author Ajay Kumar Eeralla
 * @copyright Galois, Inc.
 *
 */
module Primitive::Asymmetric::Cipher::RSA where

/*
 * There are two key types for the primitives defined in this module.
 * "Public keys" are an RSA modulus `n` paired with an encryption exponent `e`
 * subject to particular constraints. Likewise, "private keys" are a pair
 * of the RSA modulus `n` and a decryption exponent `d` related to `e`.
 * `n` in both cases is a product of two distinct odd primes.
 *
 * Deviations from RFC 8017:
 * 1. RFC 8017 allows multiple representations of the RSA private key.
 *    We ignore the alternative representation.
 * 2. RFC 8017 allows "multi-prime" RSA where `n` has more than two
 *    prime factors. We ignore this case.
 *
 * Non-conformance with NIST/FIPS:
 * 1. The bit length of the modulus `n` must be at least 2048 according
 *    to [FIPS 186-5] Appendix A.1.2, for instance. Each particular
 *    standard should be referenced carefully to determine conformance.
 * 2. Restrictions on the encryption exponent `e` in [FIPS 186-5] Section 5.4
 *    are different than the ones that appear in RFC 8017.
 * 3. The decryption exponent `d` is restricted to a particualr range in
 *    Appendix A.1.2 of [FIPS 186-5].
 * 4. This specification does not address key generation. Keys must be generated
 *    in a particular way to conform to the standard.
 */

/**
 * Section 3.1 of [RFC 8017] specifies that the encryption exponent `e`
 * is bounded by `3` and `n-1`.
 */
type constraint eValid n e = (e >= 3, e <= n - 1, fin n)

/**
 * Section 3.1 of [RFC 8017] specifies that `n` is the product of distinct
 * odd primes.
 *
 * Deviation from RFC 8017:
 * 1. This specification restricts the modulus to having two distinct factors.
 * 2. `e` is required to satisfy a GCD condition that is tedious to express
 *    in Cryptol's type system. Appeal to external validation will be required,
 *    but is provided in this module.
 *
 * Non-conformance with NIST/FIPS:
 * 1. FIPS 186-5, for instance, requires that the primes not only be distinct,
 *    but also satisfy conditions on the absolute value of their difference.
 *    These are propogated to the other standards, with some variations.
 *    Consult each standard carefully for the particular requirements.
 */
type constraint nPartialValid p q n = (n == p * q, p != q, p >= 3, q >= 3, prime p, prime q)

/**
 * The conjunction of the previous constraints for syntactic convenience.
 */
type constraint RSAPubPartialValid p q n e = (nPartialValid p q n, eValid n e)

private

      /**
       * The greatest common divisor of two positive integers
       * is the largest positive integer that divides both of them.
       *
       * This implementation is a recursive version of the famous
       * Euclidean algorithm.
       *
       * ```repl
       * :prove GCD 14 6 == 2
       * :prove GCD 25 24 == 1
       * ```
       */
      GCD : Integer -> Integer -> Integer
      GCD a b = if b == 0 then a else GCD b (a % b)

      /**
       * The least common multiple of two positive integers
       * is the smallest positive integer that is divisible by
       * both of them.
       *
       * It can be computed from the GCD.
       *
       * ```repl
       * :prove LCM 2 5 == 10
       * :prove LCM 6 9 == 18
       * ```
       */
      LCM : Integer -> Integer -> Integer
      LCM a b = (a * b) / (GCD a b)

      /**
       * RFC 8017 defines `lambda(n)` to be the LCM
       * of all of the prime factors of `n`. Our notation
       * is slightly different, but we define the same function
       * (in particular, we ignore `n`).
       */
      lambda : {p, q} (p >=3, q >=3, fin p, fin q) => Integer
      lambda = LCM (`p - 1) (`q - 1)
/**
 * For bi-prime RSA, where `n = p * q`,
 * it is a functional requirement that the
 * `GCD (e, LCM(p - 1, q - 1)) = 1`. This ensures the
 * existence of `d`. This requirement
 * is specified in Section 3.1 of RFC 8017.
 *
 * ```repl
 * // "lambda n" == 12
 * // GCD 5 12 == 1
 * :prove dExists `{5, 7, 35, 5}
 * ```
 */
dExists : {p, q, n, e} (RSAPubPartialValid p q n e) => Bit
dExists = GCD `e (lambda `{p, q}) == 1

/**
 * `d` must be specially chosen such that it is the
 * multiplicative inverse of `e` modulo `lambda n`.
 * This is specified in Section 3.2 of RFC 8017.
 *
 * `d` can be computed the extended Euclidean algorithm.
 * We do specify the generation of `d` in this module.
 *
 * ```repl
 * // 5 is its own inverse mod 12
 * :prove dCorrect `{5, 7, 35, 5, 5}
 * ```
 */
dCorrect :
      {p, q, n, e, d}
      (RSAPubPartialValid p q n e, d >= 2, d < n)
      => Bit
dCorrect = (`e * `d) % lambda `{p, q} == 1

/**
 * The RSA encryption primitive is a modular exponentiation
 * with a valid public key. In the spirit of mimicking this
 * "external validation" of the public key, we provide the minimal
 * set of constraints on `n` and `e` such that the Cryptol
 * type-checker will accept our definition.
 *
 * RSAEP is defined in Section 5.1.1 of RFC 8017.
 *
 * Deviations from RFC 8017:
 * 1. RSAEP, per the standard, considers the plaintext
 *    message representative to be an integer. Cryptol
 *    has a built-in modular arithmetic type, which we use
 *    to avoid the check for `m` being in a valid range.
 */
RSAEP: {n, e} (fin e, fin n, n >= 1) => Z n -> Z n
RSAEP m = m ^^ `e

/**
 * The RSA decryption primitive is a modular exponentiation
 * with a valid private key. In the spirit of mimicking this
 * "external validation" of the private key, we provide the minimal
 * set of constraints on `n` and `d` such that the Cryptol
 * type-checker will accept our definition.
 *
 * RSADP is defined in Section 5.1.2 of RFC 8017.
 *
 * Deviations from RFC 8017:
 * 1. RSADP, per the standard, considers the ciphertext
 *    message representative to be an integer. Cryptol
 *    has a built-in modular arithmetic type, which we use
 *    to avoid the check for `c` being in a valid range.
 * 2. RFC 8017 allows for multiple representations of the private
 *    key `K`. Although this could be modeled with an `enum`,
 *    we instead just use the (`n`, `d`) formulation in this
 *    implementation.
 */
RSADP: {n, d} (fin d, fin n, n >= 1) => Z n -> Z n
RSADP c = c ^^ `d

/**
 * The RSA signature primitive is simply the decryption primitive.
 * Only the names of the input and output arguments are changed.
 * See Section 5.2.1 of RFC 8017.
 */
RSASP1 : {n, d} (fin d, fin n, n >= 1) => Z n -> Z n
RSASP1 m = RSADP `{n, d} m

/**
 * The RSA signature verification primitive is simply the encryption primitive.
 * Only the names of the input and output arguments are changed.
 * See Section 5.2.2 of RFC 8017.
 */
RSAVP1 : {n, e} (fin e, fin n, n >= 1) => Z n -> Z n
RSAVP1 s = RSAEP `{n, e} s

private

      /**
       * Presuming that `e` and `d` are properly chosen,
       * then `RSADP` inverts `RSAEP`.
       *
       * ```repl
       * // check that this is not vacuously true
       * :prove dExists `{5, 7, 35, 5}
       * :prove dCorrect `{5, 7, 35, 5, 5}
       * // check every member of Z 35 can be decrypted
       * :exhaust rsaInvertible `{5, 7, 35, 5, 5}
       * ```
       */
      rsaInvertible :
            {p, q, n, e, d}
            (RSAPubPartialValid p q n e, d >= 2, d < n)
            => Z n -> Bit
      property rsaInvertible m =
                  preconditions ==>
                  RSADP `{n, d} (RSAEP `{n, e} m) == m
            where
                  b1 = dExists `{p, q, n, e}
                  b2 = dCorrect `{p, q, n, e, d}
                  preconditions = b1 /\ b2

      /**
       * Presuming that `e` and `d` are properly chosen,
       * then RSA signatures are verifiable.
       *
       * ```repl
       * // check that this is not vacuously true
       * :prove dExists `{5, 7, 35, 5}
       * :prove dCorrect `{5, 7, 35, 5, 5}
       * // check every member of Z 35 can be decrypted
       * :exhaust rsaInvertible `{5, 7, 35, 5, 5}
       * ```
       */
      rsaSignatureVerifiable :
            {p, q, n, e, d}
            (RSAPubPartialValid p q n e, d >= 2, d < n)
            => Z n -> Bit
      property rsaSignatureVerifiable m =
                  preconditions ==>
                  RSAVP1 `{n, e} (RSASP1 `{n, d} m) == m
            where
                  b1 = dExists `{p, q, n, e}
                  b2 = dCorrect `{p, q, n, e, d}
                  preconditions = b1 /\ b2
