/**
 * Mac-then-Encode-then-Encrypt using CBC Mode (MEE-CBC).
 *
 * MEE-CBC is used in the TLS 1.2 Record Protocol [TLS1.2].
 *
 * References:
 * [TLS1.2] T. Dierks and E. Rescorla. The Transport Layer Security (TLS)
   Protocol Version 1.2. RFC 5246, August 2008.
   @see http://www.ietf.org/rfc/rfc5246.txt.
 *
 * @copyright Galois, Inc.
 * @author Nichole Schimanski <nls@galois.com>
 * @author Alex J. Malozemoff <amaloz@galois.com>
 */

module Primitive::Symmetric::Cipher::Authenticated::MEE_CBC::Specification where

import interface Primitive::Symmetric::MAC::HMAC::Interface as HMAC
import interface Primitive::Symmetric::Cipher::Block::Modes::CBCInterface as CBC

interface constraint (CBC::BlockSize >= 8)

import Common::OptionUtils(optApply, optTest)

/**
 * MEE-CBC padding function.
 *
 * The padding works by appending `p` bytes, with each appended byte containing
   the value of `p`.
 *
 * See [TLS1.2, Section 6.2.3.2].
 */
pad : {n, p, ℓ}
      (fin n,
       // Enforces that `p ≤ 255`.
       8 >= width p,
       // `ℓ` is the padded ciphertext length, in bytes.
       ℓ == n + HMAC::TagSize + p,
       // The padded ciphertext length `ℓ` must be an integral multiple of the
       // block length.
       (8 * ℓ) % CBC::BlockSize == 0
      ) => [n][8] -> [HMAC::TagSize][8] -> [ℓ][8]
pad msg tag = (msg # tag # padding)
  where
    padding = (repeat `p) : [p][8]

/**
 * MEE-CBC unpadding function.
 *
 * This checks that the padding of a ciphertext `ct` is valid, and if so,
 * strips off the padding, returning the message and tag portions of the
 * ciphertext.
 *
 * See [TLS1.2, Section 6.2.3.2].
 */
unpad : {n, p, ℓ}
        (fin n,
         // Enforces that `p ≤ 255`.
         8 >= width p,
         // `ℓ` is the padded ciphertext length, in bytes.
         ℓ == n + HMAC::TagSize + p
        ) => [ℓ][8] -> Option ([n][8], [HMAC::TagSize][8])
unpad ct = if good then Some (m, t) else None
  where
    m = take`{n} ct
    t = take`{HMAC::TagSize, p} (drop`{n} ct)
    padding = drop`{n + HMAC::TagSize} ct
    good = padding == ((repeat `p) : [p][8])

/**
 * Validate that padding inverts as expected.
 */
property paddingInverts msg tag =
  optTest (\x -> x == (msg, tag)) unpad_pad
  where
    unpad_pad = unpad (pad msg tag)

/**
 * MEE-CBC encryption.
 *
 * The construction works as follows, where `EK` is the CBC encryption key and
 * `SK` is the HMAC signing key.
 * ```
 * MEE-CBC[EK, SK](IV, M):
 *   T = HMAC[SK](M)
 *   M_padded = pad(M, T)
 *   CT = CBC.Encrypt[EK](IV, M_padded)
 *   return CT
 * ```
 */
encrypt : {k, n, p, ℓ}
           (fin k, fin n,
            // Enforces that `p ≤ 255`.
            8 >= width p,
            // `ℓ` is the padded ciphertext length, in bytes.
            ℓ == n + HMAC::TagSize + p,
            // The padded ciphertext length `ℓ` must be an integral multiple of the
            // block length.
            (8 * ℓ) % CBC::BlockSize == 0,
            // The message length `n` must be HMAC-able, which is where this
            // constraint comes from.
            width (8 * (HMAC::KeySizeUpperBound + n)) <= HMAC::KeySizeUpperBound,
            width (8 * k) <= HMAC::KeySizeUpperBound
           ) => [CBC::KeySize] -> [k][8] -> [CBC::BlockSize] -> [n][8] -> [ℓ][8]
encrypt ekey skey iv msg = split (join ct)
  where
    tag = HMAC::hmac skey msg
    padded = pad`{n, p, ℓ} msg tag
    type nblocks = 8 * ℓ / CBC::BlockSize
    ct = CBC::encrypt`{nblocks} ekey iv (split (join padded))

/**
 * MEE-CBC decryption.
 *
 * The construction works as follows, where `EK` is the CBC encryption key and
 * `SK` is the HMAC signing key.
 * ```
 * MEE-DEC[EK, SK](CT):
 *   M_and_T = CBC.Decrypt[EK](CT)
 *   (M, T) = unpad(M_and_T), or abort if unpad fails
 *   if HMAC[SK](M) == T then
 *     return M
 *   else
 *     abort
 * ```
 */
decrypt : {k, n, p, ℓ}
           (fin k, fin n,
            // Enforces that `p ≤ 255`.
            8 >= width p,
            // `ℓ` is the padded ciphertext length, in bytes.
            ℓ == n + HMAC::TagSize + p,
            // The padded ciphertext length `ℓ` must be an integral multiple of the
            // block length.
            (8 * ℓ) % CBC::BlockSize == 0,
            // The message length `n` must be HMAC-able, which is where this
            // constraint comes from.
            width (8 * (HMAC::KeySizeUpperBound + n)) <= HMAC::KeySizeUpperBound,
            width (8 * k) <= HMAC::KeySizeUpperBound
           ) => [CBC::KeySize] -> [k][8] -> [CBC::BlockSize] -> [ℓ][8] -> Option ([n][8])
decrypt ekey skey iv ct = if valid_tag then m else None
  where
    type nblocks = 8 * ℓ / CBC::BlockSize
    pt = CBC::decrypt`{nblocks} ekey iv (split (join ct))
    m_and_t = unpad`{n, p, ℓ} (split (join pt))
    valid_tag = optTest (\x -> HMAC::hmac skey x.0 == x.1) m_and_t
    m = optApply (\x -> x.0) m_and_t

/**
 * Validate that decryption inverts encryption.
 */
property encryptInverts ekey skey iv msg =
  optTest (\x -> x == msg) (decrypt ekey skey iv ct)
    where ct = encrypt ekey skey iv msg
