/**
 * Mac-then-Encode-then-Encrypt using CBC Mode (MEE-CBC).
 *
 * MEE-CBC is used in the TLS 1.2 Record Protocol [TLS1.2].
 *
 * References:
 * [TLS1.2] T. Dierks and E. Rescorla. The Transport Layer Security (TLS)
   Protocol Version 1.2. RFC 5246, August 2008.
   @see http://www.ietf.org/rfc/rfc5246.txt.
 *
 * @copyright Galois, Inc.
 * @author Nichole Schimanski <nls@galois.com>
 * @author Alex J. Malozemoff <amaloz@galois.com>
 */

module Primitive::Symmetric::Cipher::Authenticated::MEE_CBC where

import Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES128_CBC as CBC
import Primitive::Symmetric::MAC::HMAC::Instantiations::HMAC_SHA1 as HMAC

import Common::OptionUtils(optApply, optTest)

type KeySize = 128
type SignKey = [64][8]
type BlockSize = 128
type TagSize = 20

pad : {n, p, ℓ}
      (fin n,
       8 >= width p,
       ℓ == n + TagSize + p,
       (8 * ℓ) % BlockSize == 0
      ) => [n][8] -> [TagSize][8] -> [ℓ][8]
pad msg tag = (msg # tag # padding)
  where
    padding = (repeat `p) : [p][8]

unpad : {n, p, ℓ}
        (fin n,
         8 >= width p,
         ℓ == n + TagSize + p
        ) => [ℓ][8] -> Option ([n][8], [TagSize][8])
unpad ct = if good then Some (m, t) else None
  where
    m = take `{n} ct
    t = take `{TagSize} (drop `{n} ct)
    p = drop `{n + TagSize} ct
    good = p == ((repeat `p) : [p][8]) /\ 1 <= `p /\ `p <= 16

property unpad_pad_good_1000_256 msg tag =
  optTest (\x -> x == (msg, tag)) unpad_pad
  where
    unpad_pad = unpad (pad `{n=1000,p=100} msg tag)

mee_enc : {n, p, ℓ}
          (fin n,
           8 >= width p,
           ℓ == n + TagSize + p,
           (8 * ℓ) % BlockSize == 0,
           width (8 * (64 + n)) <= 64
          ) => [KeySize] -> SignKey -> [BlockSize] -> [n][8] -> [ℓ][8]
mee_enc ekey skey iv msg = split (join ct)
  where
    tag = HMAC::hmac skey msg
    padded = pad`{n, p} msg tag
    ct = CBC::encrypt`{ℓ / 16} ekey iv (split (join padded))
    
mee_dec : {n, p, ℓ}
          (fin n,
           8 >= width p,
           ℓ == n + TagSize + p,
           (8 * ℓ) % BlockSize == 0,
           width (8 * (64 + n)) <= 64
          ) => [KeySize] -> SignKey -> [BlockSize] -> [ℓ][8] -> Option ([n][8])
mee_dec ekey skey iv ct = if valid_tag then m else None
  where
    pt = CBC::decrypt`{ℓ / 16} ekey iv (split (join ct))
    m_and_t = unpad (split (join pt))
    valid_tag = optTest (\x -> HMAC::hmac skey x.0 == x.1) m_and_t
    m = optApply (\x -> x.0) m_and_t

property mee_enc_dec_good_1000 ekey skey iv msg =
  optTest (\x -> x == msg) (mee_dec`{n=1000,p=100} ekey skey iv ct)
    where ct = mee_enc`{n=1000,p=100} ekey skey iv msg
