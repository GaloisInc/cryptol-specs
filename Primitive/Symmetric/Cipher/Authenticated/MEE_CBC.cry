/**
 * Mac-then-Encode-then-Encrypt using CBC Mode (MEE-CBC).
 *
 * MEE-CBC is used in the TLS 1.2 Record Protocol [TLS1.2].
 *
 * References:
 * [TLS1.2] T. Dierks and E. Rescorla. The Transport Layer Security (TLS)
   Protocol Version 1.2. RFC 5246, August 2008.
   @see http://www.ietf.org/rfc/rfc5246.txt.
 *
 * @copyright Galois, Inc.
 * @author Nichole Schimanski <nls@galois.com>
 * @author Alex J. Malozemoff <amaloz@galois.com>
 */

module Primitive::Symmetric::Cipher::Authenticated::MEE_CBC where

import Primitive::Symmetric::Cipher::Block::Modes::Instantiations::AES128_CBC as CBC
import Primitive::Symmetric::MAC::HMAC::Instantiations::HMAC_SHA1 as HMAC

import Common::OptionUtils(optApply, optTest)

type KeySize = 128
type SignKey = [64][8]
type BlockSize = 128
type TagSize = 20

/**
 * MEE-CBC padding function.
 *
 * The padding works by appending `p` bytes, with each appended byte containing
   the value of `p`.
 *
 * See [TLS1.2, Section 6.2.3.2].
 */
pad : {n, p, ℓ}
      (fin n,
       // Enforces that `p ≤ 255`.
       8 >= width p,
       // `ℓ` is the padded ciphertext length, in bytes.
       ℓ == n + TagSize + p,
       // The padded ciphertext length `ℓ` must be an integral multiple of the
       // block length.
       (8 * ℓ) % BlockSize == 0
      ) => [n][8] -> [TagSize][8] -> [ℓ][8]
pad msg tag = (msg # tag # padding)
  where
    padding = (repeat `p) : [p][8]

/**
 * MEE-CBC unpadding function.
 *
 * This checks that the padding of a ciphertext `ct` is valid, and if so,
 * strips off the padding, returning the message and tag portions of the
 * ciphertext.
 *
 * See [TLS1.2, Section 6.2.3.2].
 */
unpad : {n, p, ℓ}
        (fin n, fin p,
         // Enforces that `p ≤ 255`.
         8 >= width p,
         // `ℓ` is the padded ciphertext length, in bytes.
         ℓ == n + TagSize + p
        ) => [ℓ][8] -> Option ([n][8], [TagSize][8])
unpad ct = if good then Some (m, t) else None
  where
    m = take `{n} ct
    t = take `{TagSize} (drop `{n} ct)
    p = drop `{n + TagSize} ct
    good = p == ((repeat `p) : [p][8])

property unpad_pad_good_1000_256 msg tag =
  optTest (\x -> x == (msg, tag)) unpad_pad
  where
    unpad_pad = unpad (pad `{n=1000,p=100} msg tag)

/**
 * MEE-CBC encryption.
 *
 * The construction works as follows, where `EK` is the CBC encryption key and
 * `SK` is the HMAC signing key.
 * ```
 * MEE-CBC[EK, SK](IV, M):
 *   T = HMAC[SK](M)
 *   M_padded = pad(M, T)
 *   CT = CBC.Encrypt[EK](IV, M_padded)
 *   return CT
 * ```
 */
mee_enc : {n, p, ℓ}
          (fin n,
           // Enforces that `p ≤ 255`.
           8 >= width p,
           // `ℓ` is the padded ciphertext length, in bytes.
           ℓ == n + TagSize + p,
           // The padded ciphertext length `ℓ` must be an integral multiple of the
           // block length.
           (8 * ℓ) % BlockSize == 0,
           // The message length `n` must be HMAC-able, which is where this
           // constraint comes from.
           width (8 * (64 + n)) <= 64
          ) => [KeySize] -> SignKey -> [BlockSize] -> [n][8] -> [ℓ][8]
mee_enc ekey skey iv msg = split (join ct)
  where
    tag = HMAC::hmac skey msg
    padded = pad`{n, p} msg tag
    type nblocks = ℓ / (BlockSize / 8)
    ct = CBC::encrypt`{nblocks} ekey iv (split (join padded))

/**
 * MEE-CBC decryption.
 *
 * The construction works as follows, where `EK` is the CBC encryption key and
 * `SK` is the HMAC signing key.
 * ```
 * MEE-DEC[EK, SK](CT):
 *   M_and_T = CBC.Decrypt[EK](CT)
 *   (M, T) = unpad(M_and_T), or abort if unpad fails
 *   if HMAC[SK](M) == T then
 *     return M
 *   else
 *     abort
 * ```
 */
mee_dec : {n, p, ℓ}
          (fin n, fin p,
           // Enforces that `p ≤ 255`.
           8 >= width p,
           // `ℓ` is the padded ciphertext length, in bytes.
           ℓ == n + TagSize + p,
           // The padded ciphertext length `ℓ` must be an integral multiple of the
           // block length.
           (8 * ℓ) % BlockSize == 0,
           // The message length `n` must be HMAC-able, which is where this
           // constraint comes from.
           width (8 * (64 + n)) <= 64
          ) => [KeySize] -> SignKey -> [BlockSize] -> [ℓ][8] -> Option ([n][8])
mee_dec ekey skey iv ct = if valid_tag then m else None
  where
    type nblocks = ℓ / (BlockSize / 8)
    pt = CBC::decrypt`{nblocks} ekey iv (split (join ct))
    m_and_t = unpad (split (join pt))
    valid_tag = optTest (\x -> HMAC::hmac skey x.0 == x.1) m_and_t
    m = optApply (\x -> x.0) m_and_t

property mee_enc_dec_good_1000 ekey skey iv msg =
  optTest (\x -> x == msg) (mee_dec`{n=1000,p=100} ekey skey iv ct)
    where ct = mee_enc`{n=1000,p=100} ekey skey iv msg
