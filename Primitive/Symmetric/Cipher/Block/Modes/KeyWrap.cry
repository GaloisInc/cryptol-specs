
module Primitive::Symmetric::Cipher::Block::Modes::KeyWrap where

/*
 * This algorithm is only approved for instantiation with AES.
 * [SP-800-38F] Section 3.1.
 */
import interface Primitive::Symmetric::Cipher::Block::CipherInterface as C
interface constraint (C::KeySize >= 64)
interface constraint (C::BlockSize == 128)

/**
 * A byte.
 * [SP-800-38F] Section 4.1.
 */
type Octet = [8]

/**
 * Given a block cipher `C`, a bit string whose length is half of the block
 * size.
 * [SP-800-38F] Section 4.1.
 */
type Semiblock = [C::BlockSize / 2]

/**
 * The 64-bit default ICV (integrity check value) for KW.
 * [SP-800-38F] Section 4.3.
 */
ICV1 = [0xA6A6A6A6A6A6A6A6]

/**
 * The 32-bit default ICV (integrity check value) for KWP.
 * [SP-800-38F] Section 4.3.
 */
ICV2 = 0xA65959A6

/**
 * [SP-800-38F] Section 4.4.
 */
CIPHK K X = C::encrypt K X

/**
 * [SP-800-38F] Section 4.4.
 */
CIPHInvK K X = C::decrypt K X

/**
 * [SP-800-38F] Section 4.4.
 */
int = toInteger

/**
 * [SP-800-38F] Section 4.4.
 */
len : {n} (fin n) => [n] -> Integer
len _ = `n

/**
 * Get the `s` right-most bits of the input.
 * [SP-800-38F] Section 4.4.
 */
LSB : {s, n} (fin s, fin n, n >= s) => [n] -> [s]
LSB = drop`{n - s}

/**
 * Get the `s` right-most bits of the input, where the input is partitioned
 * into semiblocks.
 * This is implicitly used in [SP-800-38F] Algorithm 4.
 */
LSBArr : {s, n} (fin s, fin n, 64 * n >= s, s % 64 == 0)
    => [n]Semiblock -> [s / 64]Semiblock
LSBArr X = split (LSB (join X))

/**
 * Get the `s` left-most bits of the input.
 * [SP-800-38F] Section 4.4.
 */
MSB : {s, n} (fin s, fin n, n >= s) => [n] -> [s]
MSB = take`{s}

/**
 * Get the `s` left-most bits of the input, where the input is partitioned into
 * semiblocks.
 * This is implicitly used in [SP-800-38F] Algorithm 4.
 */
MSBArr : {s, n} (fin s, fin n, 64 * n >= s, s % 64 == 0)
    => [n]Semiblock -> [s / 64]Semiblock
MSBArr X = split (MSB (join X))

/**
 * [SP-800-38F] Section 4.5.
 * ```repl
 * :prove hexRepresentation
 * ```
 */
property hexRepresentation = 0xA659 == 0b1010011001011001

/**
 * [SP-800-38F] Section 4.5.
 * ```repl
 * :prove zeroRepresentation
 * ```
 */
property zeroRepresentation = (zero : [8]) == 0b00000000

/**
 * [SP-800-38F] Section 4.5.
 * ```repl
 * :prove concatRepresentation
 * ```
 */
property concatRepresentation = 0b001 # 0b10111 == 0b00110111

/**
 * [SP-800-38F] Section 4.5.
 * ```repl
 * :prove xorRepresentation
 * ```
 */
property xorRepresentation = 0b10011 ^ 0b10101 == 0b00110

/**
 * [SP-800-38F] Section 4.5.
 * ```repl
 * :prove lenRepresentation
 * ```
 */
property lenRepresentation = len 0b00010 == 5

/**
 * [SP-800-38F] Section 4.5.
 * ```repl
 * :prove signficanceWorks
 * ```
 */
property signficanceWorks = lsb && msb where
    X = 0b111011010
    lsb = LSB`{3} X == 0b010
    msb = MSB`{4} X == 0b1110

/**
 * The instances of the `[x]_s` notation in the spec are all used to convert
 * base-10 literal values into bit strings. We can handle these instances using
 * explicit typing in Cryptol. This property shows the expected notation and
 * demonstrates that the endianness of this conversion aligns with the
 * requirement in the specification.
 * [SP-800-38F] Section 4.5.
 * ```repl
 * :prove integerToString
 * ```
 */
property integerToString = (39 == 0b00100111) && ((39 : [8]) == 0b00100111)

/**
 * [SP-800-38F] Section 4.5.
 * ```repl
 * :prove stringToInteger
 * ```
 */
property stringToInteger = int 0b00011010 == 26

/**
 * The plaintext for AES key wrap (KW) shall be a semiblock string with fewer
 * than 2^54 semiblocks.
 * Note: the Cryptol expression `width n < X` is equivalent to `n < 2^^X - 1`.
 * [SP-800-38F] Section 5.3.1 and Table 1.
 */
type constraint KW_Plaintext n = (2 <= n, width n <= 54)

/**
 * The ciphertext for AES key wrap (KW) is a semiblock string with length one
 * longer than the corresponding ciphertext.
 * [SP-800-38F] Section 5.3.1 and Table 1.
 */
type constraint KW_Ciphertext n = (3 <= n, n <= 2^^54)

/**
 * The plaintext for AES key wrap with padding (KWP) shall be an _octet_ string
 * with fewer than 2^32 octets.
 * Note: the Cryptol expression `width n < X` is equivalent to `n < 2^^X - 1`.
 * [SP-800-38F] Section 5.3.1 and Table 1.
 */
type constraint KWP_Plaintext n = (1 <= n, width n <= 32)

/**
 * The ciphertext for AES key wrap with padding (KWP) is a semiblock string
 * with length one longer than the corresponding ciphertext.
 * [SP-800-38F] Section 5.3.1 and Table 1.
 */
type constraint KWP_Ciphertext n = (2 <= n, n <= 2^^29)

/**
 * Wrapping function for the encryption functions in AES key wrap and AES key
 * wrap with padding.
 * [SP-800-38F] Section 6.1, Algorithm 1.
 *
 * There is an additional explicit constraint here that the variable `s` must
 * fit into a semiblock. This is implied by the conversion in step 2a: `[t]_64`
 * gives the binary representation of `t` in 64 bits, and requires that `t` is
 * less than `2^64`, and the maximum value of `t` is `s`. See the definition of
 * `[]` in Section 4.4. This constraint will always be satisfied in an approved
 * instantiation due to the plaintext length restrictions from Section 5.3.1;
 * see also discussion in Appendix A.4.
 */
W : {n} (fin n, n >= 3, width (6 * (n - 1)) <= C::BlockSize / 2)
    => [C::KeySize] -> [n]Semiblock -> [n]Semiblock
W K S = C where
    // Step 1. Note that the input string is 1-indexed in the spec and
    // 0-indexed here.
    type s = 6 * (n - 1)
    A0 = S@0
    R0 = drop`{1} S

    // Step 2.
    // `At1` corresponds to `A^{t-1}` in the text. Likewise for `Rt1`.
    // In the spec, `R^t` is indexed from 2 to `n`. Here, it is indexed
    // from 0 to `n - 2`.
    update_variables : (Semiblock, [n-1]Semiblock) -> Semiblock
        -> (Semiblock, [n-1]Semiblock)
    update_variables (At1, Rt1) t = (At, Rt) where
        At = MSB`{64} (CIPHK K (At1 # Rt1@0)) ^ t
        Rnt = LSB`{64} (CIPHK K (At1 # Rt1@0))
        Rt = drop`{1} Rt1 # [Rnt]

    (As, Rs) = foldl update_variables (A0, R0) [1..s]

    // Step 3.
    C1 = [As]
    Cis = Rs
    C = C1 # Cis

/**
 * Unwrapping function for the decryption functions in AES key wrap and AES key
 * wrap with padding. This is denoted `W^{-1}` in the spec.
 * [SP-800-38F] Section 6.1, Algorithm 2.
 *
 * There is an additional explicit constraint here that the variable `s` must
 * fit into a semiblock. See note on `W`.
 */
WInv : {n} (fin n, n >= 3, width (6 * (n - 1)) <= C::BlockSize / 2)
    => [C::KeySize] -> [n]Semiblock -> [n]Semiblock
WInv K C = S where
    // Step 1. Note that the input string is 1-indexed in the spec and
    // 0-indexed here.
    type s = 6 * (n - 1)
    As = C@0
    Rs = drop`{1} C

    // Step 2.
    // `At1` corresponds to `A^{t-1}` in the text. Likewise for `Rt1`.
    // In the spec, `R^t` is indexed from 2 to `n`. Here, it is indexed
    // from 0 to `n - 2`.
    update_variables : (Semiblock, [n-1]Semiblock) -> Semiblock
        -> (Semiblock, [n-1]Semiblock)
    update_variables (At, Rt) t = (At1, Rt1) where
        At1 = MSB`{64} (CIPHInvK K ((At ^ t) # Rt@`(n-2)))
        R2t1 = LSB`{64} (CIPHInvK K ((At ^ t) # Rt@`(n-2)))
        Rt1 = [R2t1] # take`{n-2} Rt

    (A0, R0) = foldl update_variables (As, Rs) [s, s-1..1]

    // Step 3.
    S1 = [A0]
    Sis = R0
    S = S1 # Sis

/**
 * The unwrapping function `WInv` must be the inverse of the wrapping function
 * `W`.
 * [SP-800-38F] Section 5.2.
 * ```repl
 * :check wrappingInverts`{3}
 * :check wrappingInverts`{6}
 * ```
 */
wrappingInverts :
    {n} (fin n, n >= 3, width (6 * (n - 1)) <= C::BlockSize / 2)
    => [C::KeySize] -> [n]Semiblock -> Bit
property wrappingInverts K S = S == S' where
    C = W K S
    S' = WInv K C

/**
 * Authenticated encryption function for AES key wrap.
 * [SP-800-38F] Section 6.2, Algorithm 3.
 */
KW_AE : {n} (KW_Plaintext n)
    => [C::KeySize] -> [n]Semiblock -> [n + 1]Semiblock
KW_AE K P = C where
    S = ICV1 # P
    C = W K S

/**
 * Authenticated decryption function for AES key wrap.
 * [SP-800-38F] Section 6.2, Algorithm 4.
 */
KW_AD : {n} (KW_Ciphertext n)
    => [C::KeySize] -> [n]Semiblock -> Option ([n - 1]Semiblock)
KW_AD K C = if MSBArr`{64} S != ICV1 then None
    else Some (LSBArr`{64 * (n - 1)} S)
    where
        S = WInv K C

/**
 * Authenticated decryption must be the inverse of authenticated encryption for
 * AES key wrap.
 * ```repl
 * :check keyWrapInverts`{3}
 * ```
 */
keyWrapInverts : {n} (KW_Plaintext n) => [C::KeySize] -> [n]Semiblock -> Bit
property keyWrapInverts K P = inverts where
    C = KW_AE K P
    inverts = case (KW_AD K C) of
        Some maybeP -> maybeP == P
        None -> False

/**
 * The authenticated encryption function for AES key wrap with padding (KWP).
 * [SP-800-38F] Section 6.3, Algorithm 5.
 */
KWP_AE : {n} (KWP_Plaintext n, KWP_Ciphertext (n /^ 8 + 1))
    => [C::KeySize] -> [n]Octet -> [n /^ 8 + 1]Semiblock
KWP_AE K P = C where
    // The type signature checks the validity of the plaintext `P` against `n`:
    // the number of octets. `lenP` in the spec is the number of _bits_.
    type lenP = 8 * n

    // Step 2.
    type padlen = 8 * (lenP /^ 64) - (lenP / 8)

    // Step 3.
    PAD = zero : [8 * padlen]

    // Step 4. This is a string of bits; we `join P` to convert it from an
    // octet string to a bit string.
    S = ICV2 # (`(lenP / 8) : [32]) # (join P) # PAD

    // Step 5.
    C = KWP_AE_Step5`{n} K S

/**
 * This is step 5 of the KWP_AE algorithm.
 * [SP-800-38F] Section 6.3, Algorithm 5, Step 5.
 *
 * It's separated into its own function to use the numeric constraint guard,
 * which is only permitted in a top-level function.
 */
KWP_AE_Step5: {n} (KWP_Plaintext n)
    => [C::KeySize] -> [(n /^ 8 + 1) * 64] -> [n /^ 8 + 1]Semiblock
KWP_AE_Step5 K S
    | 8 * n <= 64 => split (CIPHK K S)
    | 8 * n > 64 => W K (split S)

/**
 * The authenticated decryption function for AES key wrap with padding (KWP).
 * [SP-800-38F] Section 6.3, Algorithm 6.
 *
 * This algorithm differs from the specification in that it requires the output
 * length (`m`, the length of the unpadded plaintext in octets) to be specified
 * at the top level; the specification determines the length dynamically, based
 * on the ciphertext.
 * The additional type parameter is necessary in Cryptol to allow stripping the
 * padding off the plaintext, but it introduces two concrete changes:
 *
 * 1. There is an additional type constraint, which restricts the ciphertext and
 *    plaintext lengths to be within the range of allowable padding of each
 *    other.
 *
 * 2. There are two additional failure checks, to make sure that `m` is correct
 *    with respect to the values (`Plen`, `padlen`) derived from the ciphertext:
 *    - `Plen` must be the same as `m`.
 *    - `padlen == m %^ 8`. `padlen` is the number of octets of padding needed
 *      to fill out the plaintext to the nearest semiblock (8 bytes) and `m` is
 *      the number of octets in the plaintext. We use the ceiling modulus to
 *      compute the expected amount of padding for `m`.
 *
 */
KWP_AD : {m, n} (KWP_Ciphertext n, KWP_Plaintext m, n == 1 + m /^ 8)
    => [C::KeySize] -> [n]Semiblock -> Option ([m]Octet)
KWP_AD K C =
    if (ICV2 != MSB`{32} S)                 // Step 4.
        || (padlen < 0)                     // Step 7.
        || (padlen > 7)                     // Step 7.
        || (zero   != LSB`{8 * m %^ 64} S)  // Step 8.
        || (Plen   != `m)                   // Cryptol-specific.
        || (padlen != `(m %^ 8))            // Cryptol-specific.
    then None
    else Some (split P)
    where
        S = KWP_AD_Step3 K C

        // Step 5 - 6.
        Plen = LSB`{32} (MSB`{64} S)
        padlen = 8 * (`n - 1) - Plen

        // Step 9.
        P = MSB`{8 * m} (LSB`{64 * (n - 1)} S)

/**
 * This is step 3 of the KWP_AD algorithm.
 * [SP-800-38F] Section 6.3, Algorithm 6.
 *
 * It is separated into its own function to support the numeric constraint
 * guard, which is only permitted in a top-level function.
 */
KWP_AD_Step3 : {n} (KWP_Ciphertext n)
    => [C::KeySize] -> [n]Semiblock -> [n * 64]
KWP_AD_Step3 K C
    | n == 2 => CIPHInvK K (join C)
    | n > 2 => join (WInv K C)

/**
 * Authenticated decryption must be the inverse of authenticated encryption for
 * AES key wrap with padding.
 *
 * The lengths below are chosen to check various amounts of padding.
 * ```repl
 * :check keyWrapInverts`{1}
 * :check keyWrapInverts`{3}
 * :check keyWrapInverts`{7}
 * :check keyWrapInverts`{8}
 * ```
 */
keyWrapPaddedInverts : {n} (KWP_Ciphertext (n /^ 8 + 1), KWP_Plaintext n)
    => [C::KeySize] -> [n]Octet -> Bit
property keyWrapPaddedInverts K P = inverts where
    C = KWP_AE K P
    inverts = case (KWP_AD K C) of
        Some maybeP -> maybeP == P
        None -> False
