
module Primitive::Symmetric::Cipher::Block::Modes::KeyWrap where

/*
 * This algorithm is only approved for instantiation with AES.
 * [SP-800-38F] Section 3.1.
 */
import interface Primitive::Symmetric::Cipher::Block::CipherInterface as C
interface constraint (C::KeySize >= 64)
interface constraint (C::BlockSize == 128)

/**
 * A byte.
 * [SP-800-38F] Section 4.1.
 */
type Octet = 8

/**
 * Given a block cipher `C`, a bit string whose length is half of the block
 * size.
 * [SP-800-38F] Section 4.1.
 */
type Semiblock = [C::BlockSize / 2]

/**
 * The 64-bit default ICV (integrity check value) for KW.
 * [SP-800-38F] Section 4.3.
 */
ICV1 = [0xA6A6A6A6A6A6A6A6]

/**
 * The 32-bit default ICV (integrity check value) for KWP.
 * [SP-800-38F] Section 4.3.
 */
ICV2 = 0xA65959A6

/**
 * [SP-800-38F] Section 4.4.
 */
CIPHK K X = C::encrypt K X

/**
 * [SP-800-38F] Section 4.4.
 */
CIPHInvK K X = C::decrypt K X

/**
 * [SP-800-38F] Section 4.4.
 */
int = toInteger

/**
 * [SP-800-38F] Section 4.4.
 */
len : {n} (fin n) => [n] -> Integer
len _ = `n

/**
 * Get the `s` right-most bits of the input.
 * [SP-800-38F] Section 4.4.
 */
LSB : {s, n} (fin s, fin n, n >= s) => [n] -> [s]
LSB = drop`{n - s}

/**
 * Get the `s` right-most bits of the input, where the input is partitioned
 * into semiblocks.
 * This is implicitly used in [SP-800-38F] Algorithm 4.
 */
LSBArr : {s, n} (fin s, fin n, 64 * n >= s, s % 64 == 0)
    => [n]Semiblock -> [s / 64]Semiblock
LSBArr X = split (LSB (join X))

/**
 * Get the `s` left-most bits of the input.
 * [SP-800-38F] Section 4.4.
 */
MSB : {s, n} (fin s, fin n, n >= s) => [n] -> [s]
MSB = take`{s}

/**
 * Get the `s` left-most bits of the input, where the input is partitioned into
 * semiblocks.
 * This is implicitly used in [SP-800-38F] Algorithm 4.
 */
MSBArr : {s, n} (fin s, fin n, 64 * n >= s, s % 64 == 0)
    => [n]Semiblock -> [s / 64]Semiblock
MSBArr X = split (MSB (join X))

/**
 * [SP-800-38F] Section 4.5.
 * ```repl
 * :prove hexRepresentation
 * ```
 */
property hexRepresentation = 0xA659 == 0b1010011001011001

/**
 * [SP-800-38F] Section 4.5.
 * ```repl
 * :prove zeroRepresentation
 * ```
 */
property zeroRepresentation = (zero : [8]) == 0b00000000

/**
 * [SP-800-38F] Section 4.5.
 * ```repl
 * :prove concatRepresentation
 * ```
 */
property concatRepresentation = 0b001 # 0b10111 == 0b00110111

/**
 * [SP-800-38F] Section 4.5.
 * ```repl
 * :prove xorRepresentation
 * ```
 */
property xorRepresentation = 0b10011 ^ 0b10101 == 0b00110

/**
 * [SP-800-38F] Section 4.5.
 * ```repl
 * :prove lenRepresentation
 * ```
 */
property lenRepresentation = len 0b00010 == 5

/**
 * [SP-800-38F] Section 4.5.
 * ```repl
 * :prove signficanceWorks
 * ```
 */
property signficanceWorks = lsb && msb where
    X = 0b111011010
    lsb = LSB`{3} X == 0b010
    msb = MSB`{4} X == 0b1110

/**
 * The instances of the `[x]_s` notation in the spec are all used to convert
 * base-10 literal values into bit strings. We can handle these instances using
 * explicit typing in Cryptol. This property shows the expected notation and
 * demonstrates that the endianness of this conversion aligns with the
 * requirement in the specification.
 * [SP-800-38F] Section 4.5.
 * ```repl
 * :prove integerToString
 * ```
 */
property integerToString = (39 == 0b00100111) && ((39 : [8]) == 0b00100111)

/**
 * [SP-800-38F] Section 4.5.
 * ```repl
 * :prove stringToInteger
 * ```
 */
property stringToInteger = int 0b00011010 == 26

/**
 * The plaintext for AES key wrap (KW) shall be a semiblock string with fewer
 * than 2^54 semiblocks.
 * Note: the Cryptol expression `width n < X` is equivalent to `n < 2^^X - 1`.
 * [SP-800-38F] Section 5.3.1 and Table 1.
 */
type constraint KW_Plaintext n = (2 <= n, width n <= 54)

/**
 * The ciphertext for AES key wrap (KW) is a semiblock string with length one
 * longer than the corresponding ciphertext.
 * [SP-800-38F] Section 5.3.1 and Table 1.
 */
type constraint KW_Ciphertext n = (3 <= n, n <= 2^^54)

/**
 * The plaintext for AES key wrap with padding (KWP) shall be an _octet_ string
 * with fewer than 2^32 octets.
 * Note: the Cryptol expression `width n < X` is equivalent to `n < 2^^X - 1`.
 * [SP-800-38F] Section 5.3.1 and Table 1.
 */
type constraint KWP_Plaintext n = (1 <= n, width n <= 32)

/**
 * The ciphertext for AES key wrap with padding (KWP) is a semiblock string
 * with length one longer than the corresponding ciphertext.
 * [SP-800-38F] Section 5.3.1 and Table 1.
 */
type constraint KWP_Ciphertext n = (2 <= n, n <= 2^^29)

/**
 * Wrapping function for the encryption functions in AES key wrap and AES key
 * wrap with padding.
 * [SP-800-38F] Section 6.1, Algorithm 1.
 *
 * There is an additional explicit constraint here that the variable `s` must
 * fit into a semiblock. This is implied by the conversion in step 2a: `[t]_64`
 * gives the binary representation of `t` in 64 bits, and requires that `t` is
 * less than `2^64`, and the maximum value of `t` is `s`. See the definition of
 * `[]` in Section 4.4. This constraint will always be satisfied in an approved
 * instantiation due to the plaintext length restrictions from Section 5.3.1;
 * see also discussion in Appendix A.4.
 */
W : {n} (fin n, n >= 3, width (6 * (n - 1)) <= C::BlockSize / 2)
    => [C::KeySize] -> [n]Semiblock -> [n]Semiblock
W K S = C where
    // Step 1. Note that the input string is 1-indexed in the spec and
    // 0-indexed here.
    type s = 6 * (n - 1)
    A0 = S@0
    R0 = drop`{1} S

    // Step 2.
    // `At1` corresponds to `A^{t-1}` in the text. Likewise for `Rt1`.
    // In the spec, `R^t` is indexed from 2 to `n`. Here, it is indexed
    // from 0 to `n - 2`.
    update_variables : (Semiblock, [n-1]Semiblock) -> Semiblock
        -> (Semiblock, [n-1]Semiblock)
    update_variables (At1, Rt1) t = (At, Rt) where
        At = MSB`{64} (CIPHK K (At1 # Rt1@0)) ^ t
        Rnt = LSB`{64} (CIPHK K (At1 # Rt1@0))
        Rt = drop`{1} Rt1 # [Rnt]

    (As, Rs) = foldl update_variables (A0, R0) [1..s]

    // Step 3.
    C1 = [As]
    Cis = Rs
    C = C1 # Cis

/**
 * Unwrapping function for the decryption functions in AES key wrap and AES key
 * wrap with padding. This is denoted `W^{-1}` in the spec.
 * [SP-800-38F] Section 6.1, Algorithm 2.
 *
 * There is an additional explicit constraint here that the variable `s` must
 * fit into a semiblock. See note on `W`.
 */
WInv : {n} (fin n, n >= 3, width (6 * (n - 1)) <= C::BlockSize / 2)
    => [C::KeySize] -> [n]Semiblock -> [n]Semiblock
WInv K C = S where
    // Step 1. Note that the input string is 1-indexed in the spec and
    // 0-indexed here.
    type s = 6 * (n - 1)
    As = C@0
    Rs = drop`{1} C

    // Step 2.
    // `At1` corresponds to `A^{t-1}` in the text. Likewise for `Rt1`.
    // In the spec, `R^t` is indexed from 2 to `n`. Here, it is indexed
    // from 0 to `n - 2`.
    update_variables : (Semiblock, [n-1]Semiblock) -> Semiblock
        -> (Semiblock, [n-1]Semiblock)
    update_variables (At, Rt) t = (At1, Rt1) where
        At1 = MSB`{64} (CIPHInvK K ((At ^ t) # Rt@`(n-2)))
        R2t1 = LSB`{64} (CIPHInvK K ((At ^ t) # Rt@`(n-2)))
        Rt1 = [R2t1] # take`{n-2} Rt

    (A0, R0) = foldl update_variables (As, Rs) [s, s-1..1]

    // Step 3.
    S1 = [A0]
    Sis = R0
    S = S1 # Sis

/**
 * The unwrapping function `WInv` must be the inverse of the wrapping function
 * `W`.
 * [SP-800-38F] Section 5.2.
 * ```repl
 * :check wrappingInverts`{3}
 * :check wrappingInverts`{6}
 * ```
 */
wrappingInverts :
    {n} (fin n, n >= 3, width (6 * (n - 1)) <= C::BlockSize / 2)
    => [C::KeySize] -> [n]Semiblock -> Bit
property wrappingInverts K S = S == S' where
    C = W K S
    S' = WInv K C

/**
 * Authenticated encryption function for AES key wrap.
 * [SP-800-38F] Section 6.2, Algorithm 3.
 */
KW_AE : {n} (KW_Plaintext n)
    => [C::KeySize] -> [n]Semiblock -> [n + 1]Semiblock
KW_AE K P = C where
    S = ICV1 # P
    C = W K S

/**
 * Authenticated decryption function for AES key wrap.
 * [SP-800-38F] Section 6.2, Algorithm 4.
 */
KW_AD : {n} (KW_Ciphertext n)
    => [C::KeySize] -> [n]Semiblock -> Option ([n - 1]Semiblock)
KW_AD K C = if MSBArr`{64} S != ICV1 then None
    else Some (LSBArr`{64 * (n - 1)} S)
    where
        S = WInv K C

/**
 * Authenticated decryption must be the inverse of authenticated encryption for
 * AES key wrap.
 * ```repl
 * :check keyWrapInverts`{3}
 * ```
 */
keyWrapInverts : {n} (KW_Plaintext n) => [C::KeySize] -> [n]Semiblock -> Bit
keyWrapInverts K P = inverts where
    C = KW_AE K P
    inverts = case (KW_AD K C) of
        Some maybeP -> maybeP == P
        None -> False
